<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/libchangebyme/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/libchangebyme/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="后端,Java基础," />





  <link rel="alternate" href="/atom.xml" title="伍三" type="application/atom+xml" />






<meta name="description" content="Java基础知识相关笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础知识相关笔记">
<meta property="og:url" content="http://example.com/2023/09/23/1.Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="伍三">
<meta property="og:description" content="Java基础知识相关笔记">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/images/float_1.gif">
<meta property="og:image" content="http://example.com/images/float_2.gif">
<meta property="og:image" content="http://example.com/images/float_3.gif">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191210004132894.png">
<meta property="og:image" content="http://example.com/images/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f6a6176612d646565702d616e642d7368616c6c6f772d636f70792e6a7067">
<meta property="og:image" content="http://example.com/images/image-20210427195048104.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/PPjwP.png">
<meta property="og:image" content="http://example.com/images/image-20210216210541646.png">
<meta property="og:image" content="http://example.com/images/image-20210216211744016.png">
<meta property="og:image" content="http://example.com/images/image-20210216215041849.png">
<meta property="og:image" content="http://example.com/images/image-20210216220514814.png">
<meta property="og:image" content="http://example.com/images/image-20210216220849469.png">
<meta property="og:image" content="http://example.com/images/image-20210216221903896.png">
<meta property="og:image" content="http://example.com/images/image-20210216222557043.png">
<meta property="og:image" content="http://example.com/images/image-20210216223414370.png">
<meta property="og:image" content="http://example.com/images/image-20210216223620975.png">
<meta property="og:image" content="http://example.com/images/5Qj6BiZVf0RWCRWYnl30Tg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-85dba5430f3c439e4647ea4d97ba54fc_hd.jpg">
<meta property="og:image" content="http://example.com/images/image-20210301194115914.png">
<meta property="og:image" content="http://example.com/images/image-20210217001207875.png">
<meta property="og:image" content="http://example.com/images/image-20210713220604248.png">
<meta property="og:image" content="http://example.com/images/image-20210713221140673.png">
<meta property="og:image" content="http://example.com/images/image-20210713221454439.png">
<meta property="og:image" content="http://example.com/images/image-20210713221624187.png">
<meta property="article:published_time" content="2023-09-23T13:51:13.000Z">
<meta property="article:modified_time" content="2023-09-23T12:04:07.866Z">
<meta property="article:author" content="WuSanLiu">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/float_1.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2023/09/23/1.Java基础知识/"/>





  <title>Java基础知识相关笔记 | 伍三</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">伍三</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/23/1.Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="伍三">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java基础知识相关笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-09-23T21:51:13+08:00">
                2023-09-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  27.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  108 分钟
                </span>
              
            </div>
          

          
              <div class="post-description">
                  Java基础知识相关笔记
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java基础知识相关笔记"><a href="#Java基础知识相关笔记" class="headerlink" title="Java基础知识相关笔记"></a>Java基础知识相关笔记</h1><!-- GFM-TOC -->

<ul>
<li><a href="#java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0">Java基础知识相关笔记</a></li>
<li><a href="#0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">0、面向对象</a><ul>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B">面向对象和面向过程</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7">面向对象的三大特性</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">一、数据类型</a><ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">基本类型</a><ul>
<li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6">浮点数的存储机制</a></li>
</ul>
</li>
<li><a href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B">包装类型</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E6%B1%A0">缓存池</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8Cstring">二、String</a><ul>
<li><a href="#%E6%A6%82%E8%A7%88">概览</a></li>
<li><a href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84">不可变的好处</a></li>
<li><a href="#string-stringbuffer-and-stringbuilder">String, StringBuffer and StringBuilder</a></li>
<li><a href="#string-pool">String Pool</a></li>
<li><a href="#new-stringabc">new String(“abc”)</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E8%BF%90%E7%AE%97">三、运算</a><ul>
<li><a href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a></li>
<li><a href="#float-%E4%B8%8E-double">float 与 double</a></li>
<li><a href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">隐式类型转换</a></li>
<li><a href="#switch">switch</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E5%85%B3%E9%94%AE%E5%AD%97">四、关键字</a><ul>
<li><a href="#final">final</a></li>
<li><a href="#static">static</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94object-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95">五、Object 通用方法</a><ul>
<li><a href="#%E6%A6%82%E8%A7%88-1">概览</a></li>
<li><a href="#equals">equals()</a></li>
<li><a href="#hashcode">hashCode()</a></li>
<li><a href="#equals%E5%92%8Chashcode%E7%9A%84%E8%81%94%E7%B3%BB">equals()和hashCode()的联系</a></li>
<li><a href="#tostring">toString()</a></li>
<li><a href="#clone%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D">clone()&#x2F;深浅拷贝</a><ul>
<li><a href="#1-cloneable">1. cloneable</a></li>
<li><a href="#2-%E6%B5%85%E6%8B%B7%E8%B4%9D-vs-%E6%B7%B1%E6%8B%B7%E8%B4%9D">2. 浅拷贝 VS 深拷贝</a></li>
<li><a href="#3-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D">3. 如何实现深拷贝</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%AD%E7%BB%A7%E6%89%BF">六、继承</a><ul>
<li><a href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">访问权限</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3">抽象类与接口</a><ul>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="#%E6%AF%94%E8%BE%83">比较</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9">使用选择</a></li>
</ul>
</li>
<li><a href="#super">super</a></li>
<li><a href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD">重写与重载</a><ul>
<li><a href="#%E9%87%8D%E5%86%99override">重写（Override）</a></li>
<li><a href="#%E9%87%8D%E8%BD%BDoverload">重载（Overload）</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a><ul>
<li><a href="#java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81">JAVA如何实现多态</a></li>
<li><a href="#jvm%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E8%B0%83%E7%94%A8%E7%9A%84%E6%98%AF%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95">JVM如何确定调用的是子类方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%83%E5%8F%8D%E5%B0%84">七、反射</a><ul>
<li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%82%B9">反射的优点</a></li>
<li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E7%BC%BA%E7%82%B9">反射的缺点</a></li>
<li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8">反射的应用</a><ul>
<li><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">动态代理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%AB%E5%BC%82%E5%B8%B8">八、异常</a><ul>
<li><a href="#%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB">异常分类</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E7%9B%B8%E5%85%B3%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97">异常相关的关键字</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
<li><a href="#%E4%B9%9D%E6%B3%9B%E5%9E%8B">九、泛型</a><ul>
<li><a href="#91-%E6%B3%9B%E5%9E%8B%E7%B1%BB--%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95--%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">9.1 泛型类 &amp; 泛型方法 &amp; 泛型接口</a></li>
<li><a href="#92-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF">9.2 泛型与继承</a></li>
<li><a href="#93-%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B">9.3 通配符类型</a></li>
<li><a href="#94-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">9.4 类型擦除</a><ul>
<li><a href="#941-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">9.4.1 什么是类型擦除</a></li>
<li><a href="#942-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">9.4.2 类型擦除引起的问题及解决方法</a><ul>
<li><a href="#9421-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">9.4.2.1 自动类型转换</a></li>
<li><a href="#9422-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E4%B8%8E%E5%A4%9A%E6%80%81%E7%9A%84%E5%86%B2%E7%AA%81">9.4.2.2 类型擦除与多态的冲突</a></li>
<li><a href="#943-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E6%95%B0%E7%BB%84">9.4.3 泛型与数组</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#95-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">9.5 参考资料</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E6%B3%A8%E8%A7%A3">十、注解</a></li>
<li><a href="#%E5%8D%81%E4%B8%80%E7%89%B9%E6%80%A7">十一、特性</a><ul>
<li><a href="#java-%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">Java 各版本的新特性</a><ul>
<li><a href="#1-jdk18%E6%96%B0%E7%89%B9%E6%80%A7">1 JDK1.8新特性</a></li>
<li><a href="#2-jdk17-%E6%96%B0%E7%89%B9%E6%80%A7">2 JDK1.7 新特性</a></li>
</ul>
</li>
<li><a href="#java-%E4%B8%8E-c-%E7%9A%84%E5%8C%BA%E5%88%AB">Java 与 C++ 的区别</a></li>
<li><a href="#jre-or-jdk">JRE or JDK</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%BA%8Cio">十二、IO</a><ul>
<li><a href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%94%E5%A4%A7io%E6%A8%A1%E5%9E%8B">1 操作系统的五大IO模型</a><ul>
<li><a href="#%E9%98%BB%E5%A1%9Eio">阻塞IO</a></li>
<li><a href="#%E9%9D%9E%E9%98%BB%E5%A1%9Eio">非阻塞IO</a></li>
<li><a href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io">多路复用IO</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io">信号驱动IO</a></li>
<li><a href="#%E5%BC%82%E6%AD%A5io">异步IO</a></li>
<li><a href="#%E4%BA%94%E5%A4%A7io%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94">五大IO模型对比</a></li>
</ul>
</li>
<li><a href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84selectpollepoll%E6%9C%BA%E5%88%B6">2 操作系统的select、poll、epoll机制</a><ul>
<li><a href="#select">select</a></li>
<li><a href="#poll">poll</a></li>
<li><a href="#epoll">epoll</a></li>
<li><a href="#%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94">三者对比</a></li>
<li><a href="#%E5%8F%82%E8%80%83-1">参考</a></li>
</ul>
</li>
<li><a href="#3-java%E6%8F%90%E4%BE%9B%E7%9A%84bionioaio%E6%A8%A1%E5%9E%8B">3 JAVA提供的BIO、NIO、AIO模型</a><ul>
<li><a href="#bio%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9Eio">BIO（同步阻塞IO）</a></li>
<li><a href="#nio%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9Eio">NIO（同步非阻塞IO）</a></li>
<li><a href="#aio%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9Eio">AIO（异步非阻塞IO）</a></li>
</ul>
</li>
<li><a href="#4-reactornetty%E4%BD%BF%E7%94%A8%E7%9A%84io-%E6%A8%A1%E5%9E%8B">4 Reactor（Netty使用的）IO 模型</a><ul>
<li><a href="#41-reactor%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">4.1 Reactor基本思想</a></li>
<li><a href="#42-reactor%E6%A8%A1%E5%9E%8B%E6%9E%84%E6%88%90">4.2 Reactor模型构成</a></li>
<li><a href="#43-reactor%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0">4.3 Reactor模型实现</a><ul>
<li><a href="#431-%E5%8D%95reactor%E5%8D%95%E7%BA%BF%E7%A8%8B">4.3.1 单Reactor单线程</a></li>
<li><a href="#432-%E5%8D%95reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B">4.3.2 单Reactor多线程</a></li>
<li><a href="#433-%E5%A4%9Areactor%E5%A4%9A%E7%BA%BF%E7%A8%8B">4.3.3 多Reactor多线程</a></li>
</ul>
</li>
<li><a href="#44-%E6%80%BB%E7%BB%93">4.4 总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%89%E9%9B%86%E5%90%88">十三、集合</a><br>* <a href="#1-hashmap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">1 HashMap实现原理</a><br>   * <a href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">存储结构</a><br>   * <a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</a><br>   * <a href="#put%E6%96%B9%E6%B3%95">PUT()方法</a><br>   * <a href="#get%E6%96%B9%E6%B3%95">GET()方法</a><br>   * <a href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">扩容机制</a><br>   * <a href="#hashmap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">HashMap线程安全问题</a><br>* <a href="#2-concurrenthashmap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">2 ConcurrentHashMap实现原理</a><br>   * <a href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-1">存储结构</a><br>   * <a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1">构造方法</a><br>   * <a href="#put%E6%96%B9%E6%B3%95-1">PUT()方法</a><br>   * <a href="#get%E6%96%B9%E6%B3%95-1">GET()方法</a><br>   * <a href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6-1">扩容机制</a><br>   * <a href="#size%E6%96%B9%E6%B3%95">size()方法</a><br>* <a href="#3-jdk18%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91">3 JDK1.8为什么使用红黑树？</a><br>* <a href="#4-hashmap%E5%92%8Chashtable%E7%9A%84%E5%8C%BA%E5%88%AB">4 HashMap和HashTable的区别</a><br>* <a href="#5-arraylist%E5%92%8Cvector%E5%8E%9F%E7%90%86">5 ArrayList和Vector原理</a><br>* <a href="#6-arraylist%E5%92%8Clinkedlist%E5%8C%BA%E5%88%AB">6 ArrayList和LinkedList区别</a></li>
<li><a href="#%E5%85%B6%E5%AE%83%E9%9D%A2%E8%AF%95%E9%A2%98">其它面试题</a><br>* <a href="#1-java%E5%92%8Cc%E7%9A%84%E5%8C%BA%E5%88%AB">1 Java和C++的区别？</a><br>* <a href="#2-classnotfoundexception%E5%92%8C-noclassdeffounderror%E5%8C%BA%E5%88%AB">2 ClassNotFoundException和 NoClassDefFoundError区别</a><br>   * <a href="#classnotfoundexception">ClassNotFoundException</a><br>   * <a href="#noclassdeffounderror">NoClassDefFoundError</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->

<h1 id="0、面向对象"><a href="#0、面向对象" class="headerlink" title="0、面向对象"></a>0、面向对象</h1><h2 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h2><p>向对象程序设计(Object Oriented Programming)作为一种新方法，其本质是以建立模型体现出来的抽象思维过程和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089">面向对象</a>的方法。模型是用来反映现实世界中事物特征的。任何一个模型都不可能反映客观事物的一切具体特征，只能对事物特征和变化规律的一种抽象，且在它所涉及的范围内更普遍、更集中、更深刻地描述客体的特征。通过建立模型而达到的抽象是人们对客体认识的深化。</p>
<p><strong>面向过程</strong>让计算机有步骤地顺序做一件事，是<strong>过程化思维</strong>，使用面向过程语言开发大型项目，软件复用和维护存在很大问题，<strong>模块之间耦合严重</strong>。</p>
<p><strong>面向对象</strong>相对面向过程<strong>更适合解决规模较大的问题，</strong>可以拆解问题复杂度，对现实事物进行抽象并映射为开发对象（事物的特征用属性表示、事物的行为和能力用方法表示），更接近人的思维。 </p>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p><font color="blue"><strong>Java面向对象三大特性：封装、继承、多态。</strong></font></p>
<blockquote>
<p>在 Java 中有两种形式可以实现多态：<strong>继承</strong>（多个子类对同一方法的重写）和 <strong>接口</strong>（实现接口并覆盖接口中同一方法）。</p>
</blockquote>
<h1 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h1><p>Java的中的数据类型分为基本类型和包装类型，两种有以下区别：</p>
<ul>
<li><strong>存储内容</strong>：基本类型变量直接存储数据，包装类型存指针</li>
<li><strong>存储位置</strong>：基本类型数据存储在栈中、包装类型数据存储在堆中（对象都在堆中）</li>
<li><strong>容器使用</strong>：容器中只能存储包装类型，不能存储基本类型（需要做自动装箱）</li>
<li><strong>方法</strong>：基本类型没有方法，包装类型有各种方法如<code>min,max,equals</code>等</li>
<li><strong>默认值</strong>：基本类型为0&#x2F;false，包装类型为<code>null</code></li>
</ul>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul>
<li>boolean&#x2F;~</li>
<li>byte&#x2F;8</li>
<li>char&#x2F;16</li>
<li>short&#x2F;16</li>
<li>int&#x2F;32</li>
<li>float&#x2F;32</li>
<li>long&#x2F;64</li>
<li>double&#x2F;64</li>
</ul>
<blockquote>
<p>Java基本类型的长度和平台无关，因为Java运行在JVM上，JVM对上屏蔽了系统差异性。</p>
</blockquote>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。<strong>JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">Primitive Data Types</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">The Java® Virtual Machine Specification</a></li>
</ul>
<h3 id="浮点数的存储机制"><a href="#浮点数的存储机制" class="headerlink" title="浮点数的存储机制"></a>浮点数的存储机制</h3><blockquote>
<p>浮点数存在精度损失问题，一般不直接使用<code>==</code>或<code>!=</code>进行比较，而是作差后和一个非常小的数字进行比价<code>如x-y &lt; eps = 10^-8</code>则认为<code>x==y</code>。</p>
</blockquote>
<p>浮点数一般采用科学计数法来表示和存储，单精度和双精度<strong>都分为三个部分：</strong></p>
<ul>
<li><p><strong>符号位</strong> (Sign)：0代表正数，1代表为负数；</p>
</li>
<li><p><strong>指数位</strong> (Exponent)：用于存储科学计数法中的指数数据；</p>
</li>
<li><p><strong>尾数部分</strong> (Mantissa)：采用移位存储尾数部分；</p>
</li>
</ul>
<p><strong>float</strong></p>
<p><img src="/images/float_1.gif" alt="img"></p>
<p><strong>double</strong></p>
<p><img src="/images/float_2.gif" alt="img"></p>
<p>如<code>8.25f</code>表示为<code>8.25 * 10^0</code>，对应的二进制表示为<code>1000.01b = 1.0001b * 2^3</code>，<font color="red">（任何小数都可以表示为1.xyz * 2^n，所以第一个1可以去掉，实际上尾数有效位为24位）</font>，所以8.25的存储方式为：</p>
<p><img src="/images/float_3.gif" alt="img"></p>
<p>参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuyuan2011woaini/p/4105765.html">浮点数在计算机中的存储方式 - wuyuan2011woaini - 博客园 (cnblogs.com)</a></p>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;     <span class="comment">// 装箱 调用了 Integer.valueOf(2)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;         <span class="comment">// 拆箱 调用了 X.intValue()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">Autoboxing and Unboxing</a></li>
</ul>
<blockquote>
<p>问：有了基础类型为什么还需要包装类？</p>
<p>答：Java是面向对象语言，包装类让基础类型有了对象的特性，方便用在各种容器中（如HashMap数据系相关操作需要用到<code>hashCode()</code>和<code>equals()</code>方法等等，这些在基础类型中是没有的）。</p>
</blockquote>
<h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 8 中，<strong>Integer 缓存池的大小默认为 -128~127</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// 指针比较, true</span></span><br></pre></td></tr></table></figure>

<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax&#x3D;&lt;size&gt; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123">StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123</a></p>
<h1 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>String 被声明为 final，因此它不可被继承。</strong>(Integer 等包装类也不能被继承）</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<h2 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h2><p><strong>1. 可以缓存 hash 值</strong>  </p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong>  </p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191210004132894.png"/> </div><br>

<p><strong>3. 安全性</strong>  </p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong>  </p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<p><a target="_blank" rel="noopener" href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/">Program Creek : Why String is immutable in Java?</a></p>
<h2 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h2><p><strong>1. 可变性</strong>  </p>
<ul>
<li>String 不可变（成员变量<code>char[]</code>使用过了<code>final</code>进行修饰）</li>
<li>StringBuffer 和 StringBuilder 可变（成员变量<code>char[]</code>支持自动扩容）</li>
</ul>
<p><strong>2. 线程安全</strong>  </p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<p><strong>使用场景</strong>：操作&#x2F;改变少量数据可以使用String，大量&#x2F;频繁拼接字符串综合考虑线程安全要求来使用<code>StringBuilder</code>或<code>StringBuffer</code>。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder">StackOverflow : String, StringBuffer, and StringBuilder</a></p>
<h2 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h2><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/10578984/what-is-string-interning">StackOverflow : What is String interning?</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/in_depth_understanding_string_intern.html">深入解析 String#intern</a></li>
</ul>
<h2 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h2><p>使用这种方式<strong>一共会创建两个字符串对象</strong>（前提是 String Pool 中还没有 “abc” 字符串对象）。</p>
<ul>
<li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewStringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Constant pool:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">18</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">19</span>            <span class="comment">// abc</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               java/lang/String</span><br><span class="line">  #<span class="number">19</span> = Utf8               abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String abc</span></span><br><span class="line">         <span class="number">6</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">9</span>: astore_1</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = original.value;</span><br><span class="line">    <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Java 的参数是以<strong>值传递</strong>的形式传入方法中，而不是引用传递。</p>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是<strong>将对象的地址以值的方式传递到形参中</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getObjectAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PassByValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        dog.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassByValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@74a14482</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/693732">深入理解Java中方法的参数传递机制</a></p>
<h2 id="float-与-double"><a href="#float-与-double" class="headerlink" title="float 与 double"></a>float 与 double</h2><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1;</span></span><br></pre></td></tr></table></figure>

<p>1.1f 字面量才是 float 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure>

<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;</span></span><br></pre></td></tr></table></figure>

<p>但是使用 +&#x3D; 或者 ++ 运算符会执行隐式类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;</span><br><span class="line">s1++;</span><br></pre></td></tr></table></figure>

<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = (<span class="type">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting">StackOverflow : Why don’t Java’s +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D; compound assignment operators require casting?</a></p>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// long x = 111;</span></span><br><span class="line"><span class="comment">// switch (x) &#123; // Incompatible types. Found: &#x27;long&#x27;, required: &#x27;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum&#x27;</span></span><br><span class="line"><span class="comment">//     case 111:</span></span><br><span class="line"><span class="comment">//         System.out.println(111);</span></span><br><span class="line"><span class="comment">//         break;</span></span><br><span class="line"><span class="comment">//     case 222:</span></span><br><span class="line"><span class="comment">//         System.out.println(222);</span></span><br><span class="line"><span class="comment">//         break;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java">StackOverflow : Why can’t your switch statement data type be long, Java?</a></p>
<h1 id="四、关键字"><a href="#四、关键字" class="headerlink" title="四、关键字"></a>四、关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p><strong>1. 数据</strong>  </p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使<strong>数值不变</strong>；</li>
<li>对于引用类型，final 使<strong>引用不变</strong>，也就不能引用其它对象，但是<strong>被引用的对象本身是可以修改的</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable &#x27;x&#x27;</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">A</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2. 方法</strong>  </p>
<p>声明方法<strong>不能被子类重写</strong>。</p>
<p><strong>private 方法隐式地被指定为 final</strong>，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<p><strong>3. 类</strong>  </p>
<p>声明类<strong>不允许被继承</strong>。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><strong>1. 静态变量</strong>  </p>
<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a.x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 静态方法</strong>  </p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">// int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="comment">// int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 静态语句块</strong>  </p>
<p>静态语句块在类初始化时运行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>

<p><strong>4. 静态内部类</strong>  </p>
<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">staticInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<blockquote>
<p>单例模式可以使用静态内部类的写法！</p>
</blockquote>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<p><strong>6. 初始化顺序</strong>  </p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;静态变量&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> <span class="string">&quot;实例变量&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后才是构造函数的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InitialOrderTest</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h1 id="五、Object-通用方法"><a href="#五、Object-通用方法" class="headerlink" title="五、Object 通用方法"></a>五、Object 通用方法</h1><h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>

<h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p><strong>1. 等价关系</strong>  </p>
<p>两个对象具有等价关系，需要满足以下五个条件：</p>
<p>Ⅰ 自反性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅱ 对称性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅲ 传递性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p>Ⅳ 一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Ⅴ 与 null 的比较</p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(<span class="literal">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. &#x3D;&#x3D;和equals的区别</strong>  </p>
<ul>
<li>对于基本类型，<code>==</code> 判断两个值是否相等，基本类型没有 <code>equals()</code> 方法。</li>
<li>对于引用类型，<code>==</code> 判断两个变量是否引用同一个对象，即地址是否相同</li>
<li><code>equals</code>默认比较的是两个对象的地址是否相同（<code>==</code>），用户也可以重新该方法，实现比较对象的属性是否相同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 实现</strong>  </p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EqualExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">EqualExample</span> <span class="variable">that</span> <span class="operator">=</span> (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。<strong>等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价</strong>，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</p>
<blockquote>
<p>hashCode()方法默认为native实现，由JVM来做具体实现，根据对象的地址返回一个整数代表哈希码（一般情况下不同对象返回的哈希码是不同的）。</p>
<p><strong>要求equals()判断相等的对象hashCode也要相等！两者需要一起重写！</strong></p>
</blockquote>
<p>HashSet  和 HashMap 等集合类使用了 hashCode()  方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode()  方法。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EqualExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualExample</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">EqualExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualExample</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size());   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p>
<p>R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="equals-和hashCode-的联系"><a href="#equals-和hashCode-的联系" class="headerlink" title="equals()和hashCode()的联系"></a>equals()和hashCode()的联系</h2><p>重写<code>equals()</code>方法必须重写<code>hashCode()</code>方法（保证两个相等对象的哈希值相同，因为将对象放入类似Map的集合中时，会利用<code>hashCode</code>来计算下标，比较对象是否相同时最后会使用<code>equals()</code>来比较）。</p>
<ul>
<li>两个对象<code>equals()</code>相等则<code>hashCode()</code>必须相等。</li>
<li>两个对象<code>hashCode()</code>相等<code>equals()</code>不一定相等，可能是哈希冲突。</li>
</ul>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ToStringExample</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ToStringExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToStringExample</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(example.toString());</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ToStringExample@4554617c</span><br></pre></td></tr></table></figure>

<h2 id="clone-深浅拷贝"><a href="#clone-深浅拷贝" class="headerlink" title="clone()&#x2F;深浅拷贝"></a>clone()&#x2F;深浅拷贝</h2><h3 id="1-cloneable"><a href="#1-cloneable" class="headerlink" title="1. cloneable"></a>1. cloneable</h3><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneExample</span>();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span></span><br></pre></td></tr></table></figure>

<p>重写 clone() 得到以下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneExample</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">CloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.CloneNotSupportedException: CloneExample</span><br></pre></td></tr></table></figure>

<p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-浅拷贝-VS-深拷贝"><a href="#2-浅拷贝-VS-深拷贝" class="headerlink" title="2. 浅拷贝 VS 深拷贝"></a>2. 浅拷贝 VS 深拷贝</h3><p><strong>浅拷贝</strong>：拷贝对象和原始对象的引用类型引用同一个对象。对原始对象的修改会影响拷贝对象。</p>
<p><strong>深拷贝</strong>：拷贝对象和原始对象的引用类型引用不同对象。对原始对象的修改并不会影响拷贝对象。</p>
<p><img src="/images/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f6a6176612d646565702d616e642d7368616c6c6f772d636f70792e6a7067" alt="deep and shallow copy"></p>
<h3 id="3-如何实现深拷贝"><a href="#3-如何实现深拷贝" class="headerlink" title="3. 如何实现深拷贝"></a>3. 如何实现深拷贝</h3><p><strong>实现Clonable接口</strong>：重写其中的clone方法即可，可能抛出类强制转换失败的异常。</p>
<p><strong>手动实现拷贝方法</strong>：将类中的手动进行赋值。</p>
<p><strong>序列化&#x2F;反序列化</strong>：将对象序列化生成的数据（如json或二进制数据）重新反序列化生成新的对象，使用序列化的前提是拷贝的类（包括其成员变量）需要实现Serializable接口。</p>
<p><img src="/images/image-20210427195048104.png" alt="image-20210427195048104"></p>
<h1 id="六、继承"><a href="#六、继承" class="headerlink" title="六、继承"></a>六、继承</h1><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>
<p>可以对类或类中的成员（字段和方法）加上访问修饰符。</p>
<ul>
<li>类可见表示其它类可以用这个类创建实例对象。</li>
<li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li>
</ul>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p>如果子类的方法重写了父类的方法，那么<strong>子类中该方法的访问级别不允许低于父类的访问级别</strong>。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。</p>
<p><strong>字段决不能是公有的</strong>，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = Integer.valueOf(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessWithInnerClassExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccessWithInnerClassExample</span><span class="params">()</span> &#123;</span><br><span class="line">        innerClass = <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerClass.x;  <span class="comment">// 直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个类没有包含足够多的信息来描述一个具体的对象，这样的类就是抽象类。抽象类和抽象方法都使用 abstract 关键字进行声明。<strong>如果一个类中包含抽象方法，那么这个类必须声明为抽象类</strong>。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClassExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title class_">AbstractClassExample</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line"><span class="type">AbstractClassExample</span> <span class="variable">ac2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractExtendClassExample</span>();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是抽象类的延伸，接口里面定义了很多没有实现的方法，只是起一个合约规范的作用，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p><strong>从 Java 8 开始，接口也可以拥有默认的方法实现</strong>，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</p>
<p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p>
<p><strong>接口的字段默认都是 static 和 final 的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;               // Variable &#x27;y&#x27; might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">0</span>;       <span class="comment">// Modifier &#x27;public&#x27; is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier &#x27;private&#x27; not allowed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title class_">InterfaceExample</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); // &#x27;InterfaceExample&#x27; is abstract; cannot be instantiated</span></span><br><span class="line"><span class="type">InterfaceExample</span> <span class="variable">ie2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceImplementExample</span>();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系（<em>一个类实现了什么接口 &#x3D; 一个类具备接口定义的功能</em>），它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，<strong>一个类可以实现多个接口，但是不能继承多个抽象类</strong>。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
<h3 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h3><p>使用接口：</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，<strong>接口优先于抽象类</strong>（优先使用组合而不是继承）。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">Abstract Methods and Classes</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/">深入理解 abstract class 和 interface</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface">When to Use Abstract Class and Interface</a></li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title class_">SuperExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperExtendExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(x, y);</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExtendExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SuperExample</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperExtendExample</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html">Using the Keyword super</a></p>
<h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><h3 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h3><blockquote>
<p>方法名字、传入参数、返回类型完全相同！</p>
</blockquote>
<p>存在于继承体系中，指子类实现了一个与父类在方法<strong>声明上完全相同</strong>的一个方法。</p>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li><strong>子类方法的返回类型必须是父类方法返回类型或为其子类型</strong>。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p>
<ul>
<li>子类方法访问权限为 public，大于父类的 protected。</li>
<li>子类的返回类型为 ArrayList<Integer>，是父类返回类型 List<Integer> 的子类。</li>
<li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li>
<li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Integer&gt; <span class="title function_">func</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">func</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ul>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    A</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    B</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    C</span></span><br><span class="line"><span class="comment">    |</span></span><br><span class="line"><span class="comment">    D</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(A obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A.show(A)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(C obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A.show(C)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(A obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B.show(A)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 A 中存在 show(A obj)，直接调用</span></span><br><span class="line">    a.show(a); <span class="comment">// A.show(A)</span></span><br><span class="line">    <span class="comment">// 在 A 中不存在 show(B obj)，将 B 转型成其父类 A</span></span><br><span class="line">    a.show(b); <span class="comment">// A.show(A)</span></span><br><span class="line">    <span class="comment">// 在 B 中存在从 A 继承来的 show(C obj)，直接调用</span></span><br><span class="line">    b.show(c); <span class="comment">// A.show(C)</span></span><br><span class="line">    <span class="comment">// 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C</span></span><br><span class="line">    b.show(d); <span class="comment">// A.show(C)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用的还是 B 对象，所以 ba 和 b 的调用结果一样</span></span><br><span class="line">    <span class="type">A</span> <span class="variable">ba</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    ba.show(c); <span class="comment">// A.show(C)</span></span><br><span class="line">    ba.show(d); <span class="comment">// A.show(C)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h3><blockquote>
<p><strong>方法名字、返回类型相同</strong>，但是传入参数类型&#x2F;个数&#x2F;顺序不同。</p>
</blockquote>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是<strong>参数类型、个数、顺序</strong>至少有一个不同。</p>
<p>应该注意的是，<strong>返回值不同，其它都相同不算是重载</strong>（不允许这样写）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有以下两个函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">// 进行下面的调用时，编译器无法判断是要调用哪一个函数</span></span><br><span class="line">max(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是<strong>编译时的多态性</strong>，而后者实现的是<strong>运行时的多态性</strong>。</p>
</blockquote>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="JAVA如何实现多态"><a href="#JAVA如何实现多态" class="headerlink" title="JAVA如何实现多态"></a>JAVA如何实现多态</h3><p><font color="blue">通过方法<strong>重写</strong>（子类方法覆盖父类方法&#x2F;接口的多个实现类）或者<strong>重载</strong>(方法入参不同，其余相同)来实现多态。</font></p>
<h3 id="JVM如何确定调用的是子类方法"><a href="#JVM如何确定调用的是子类方法" class="headerlink" title="JVM如何确定调用的是子类方法"></a>JVM如何确定调用的是子类方法</h3><p>在Java中，方法调用有两类，动态方法调用与静态方法调用：</p>
<ul>
<li><p><strong>静态方法调用</strong>是指对于类的静态方法的调用方式，是在编译时刻就已经确定好具体调用方法的情况，是静态绑定的。</p>
</li>
<li><p><strong>动态方法调用</strong>需要有方法调用所作用的对象，是在调用的时候才确定具体的调用方法，是动态绑定的。</p>
</li>
</ul>
<p><strong>多态则是采用动态方法调用。</strong></p>
<p><font color="green">JVM如何确定具体需要执行那个方法的流程如下：</font></p>
<ul>
<li>首先找到变量&#x2F;引用的实际类型（虚拟机栈指针指向堆中的实际对象）</li>
<li>在实际类型中寻找符合要求的方法（实际对象对应方法区中的class的方法表）</li>
<li>如果实际类型中没有符合要求的方法，则继续往父类中寻找</li>
<li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常</li>
</ul>
<h1 id="七、反射"><a href="#七、反射" class="headerlink" title="七、反射"></a>七、反射</h1><p>每个类都有一个   <strong>Class</strong>   <strong>对象</strong>，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><strong>Field</strong>  ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong>  ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong>  ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<h2 id="反射的优点"><a href="#反射的优点" class="headerlink" title="反射的优点"></a>反射的优点</h2><ul>
<li><pre><code>**可扩展性**   ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
</code></pre>
</li>
<li><pre><code>**类浏览器和可视化开发环境**   ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
</code></pre>
</li>
<li><pre><code>**调试器和测试工具**   ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。
</code></pre>
</li>
</ul>
<h2 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h2><p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li><pre><code>**性能开销**   ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
</code></pre>
</li>
<li><pre><code>**安全限制**   ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
</code></pre>
</li>
<li><pre><code>**内部暴露** 【重要】  ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。
</code></pre>
</li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/index.html">Trail: The Reflection API</a></li>
<li><a target="_blank" rel="noopener" href="http://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析 Java 反射（1）- 基础</a></li>
</ul>
<h2 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>利用JDK的动态代理，可以不需要对每个代理目标都编写一个对应的代理类（代理类也需要实现代理目标实现的接口，并传入一个代理目标作为成员变量），<code>InvocationHandler</code>可以利用反射自动为传入的对象生成代理类。</p>
<blockquote>
<p>为什么不直接用继承+重写的方法来进行功能增强呢？因为可能别人写的程序我们没有源代码，只有class文件，无法重写。</p>
<p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在代理目标接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使我们的类职责更加单一，复用性更强。</p>
</blockquote>
<p>直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理：需要实现InvocationHandler接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定委托对象，并返回代理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 绑定代理目标并为其动态生成一个代理对象返回</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">bind</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="comment">//绑定该类实现的所有接口，取得代理类</span></span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 在调用自动生成的代理对象的方法是会自动调用本方法，可以实现不对代理目标的方法进行重写的前提下进行方法功能增强（如加入日志打印。权限控制等）！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 直接调用对象的实际方法，此处也可做一些调用权限控制</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;destroy&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalAccessError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        result = method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理目标：必须实现某个接口！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealSubject: do operation()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealSubject: destroy()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h1><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p><code>Throwable </code>可以用来表示任何可以作为异常抛出的类，分为两种：</p>
<ul>
<li><strong>Error</strong>：<code>Error</code>类对象由 Java 虚拟机生成并抛出（如内存溢出。堆栈溢出），大多数错误与代码编写者所执行的操作无关。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，不应该试图去处理它所引起的异常状况。</li>
<li><strong>Exception</strong>：<ul>
<li><strong>运行时异常</strong>  ：<code>RuntimeExdeption</code>，如空指针、越界、算术异常或用户自定义的异常等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</li>
<li><strong>非运行时异常</strong>  ：除<code>RuntimeExdeption</code>之外的异常，如<code>IOException</code>，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。</li>
</ul>
</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/PPjwP.png" width="600"/> </div><br>

<blockquote>
<p><code>不受检查异常</code>：包括<code>RuntimeException</code>及其子类和<code>Error</code>，无法预测，在程序执行过程中才可能发生。</p>
<p><code>检查异常</code>：在正确的程序运行过程中，很容易出现的、情理可容的异常状况，在一定程度上这种异常的发生是可以预测的，并且一旦发生该种异常，就必须采取某种方式进行处理（try…catch…&#x2F;throw进行处理）。</p>
</blockquote>
<h2 id="异常相关的关键字"><a href="#异常相关的关键字" class="headerlink" title="异常相关的关键字"></a>异常相关的关键字</h2><p><strong>try…catch..finally</strong></p>
<p>不做过多介绍。</p>
<p>finally中的语句无论是否出现异常，以及出现的异常是否被catch捕获，都可以成功执行！</p>
<p><font color="red">finally中的语句会在try&#x2F;catch语句块里的return之前执行！！！即使它们显示调用了return</font></p>
<p><strong>throw</strong></p>
<p>可以用在捕获到异常后将异常向上抛出（因为自己无法处理，所以将改异常交给方法调用者处理），<code>throw</code>被执行后方法立即返回，后面的语句将不会被执行。</p>
<p><strong>throws</strong></p>
<p>配置<code>throw</code>关键字使用，如果本方法不想处理异常（不用<code>try..catch</code>处理）或直接<code>throw</code>，则必须（前提是这是一个<strong>受检异常</strong>）在方法上用<code>throws</code>抛出该方法执行可能出现的异常，供方法调用者进行处理。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            createException1(); <span class="comment">// 必须捕获异常或在方法上throws</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        createException2();	<span class="comment">// 会被执行</span></span><br><span class="line"></span><br><span class="line">        createException2(); <span class="comment">// 不会被执行, 因为上一个异常未处理，线程退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createException1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Exception1:非运行时异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createException2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 造一个异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception2:运行时异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;	<span class="comment">// 非运行时异常可以不做任何处理(不需要在方法上throws声明，调用者也可以不处理，如果调用者要处理必须先在方法上声明)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 输出打印 ---------</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.lang.Exception: Exception1:非运行时异常</span></span><br><span class="line"><span class="comment">	at test.ExceptionTest.createException1(ExceptionTest.java:27)</span></span><br><span class="line"><span class="comment">	at test.ExceptionTest.main(ExceptionTest.java:11)</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.RuntimeException: Exception2:运行时异常</span></span><br><span class="line"><span class="comment">	at test.ExceptionTest.createException2(ExceptionTest.java:36)</span></span><br><span class="line"><span class="comment">	at test.ExceptionTest.main(ExceptionTest.java:15)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Throws</code>抛出异常的规则：</p>
<ul>
<li>如果是不受检查异常（<code>unchecked exception</code>），即<code>Error</code>、<code>RuntimeException</code>或它们的子类，那么可以不使用<code>throws</code>关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li>
<li>必须声明方法可抛出的任何检查异常（<code>checked exception</code>）。即如果一个方法可能出现受可查异常，要么用<code>try-catch</code>语句捕获，要么用<code>throws</code>子句声明将它抛出，否则会导致编译错误</li>
<li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li>
<li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li>
</ul>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.tianmaying.com/tutorial/Java-Exception">Java 入门之异常处理</a></li>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/7383.html">Java 异常的面试问题及答案 -Part 1</a></li>
</ul>
<h1 id="九、泛型"><a href="#九、泛型" class="headerlink" title="九、泛型"></a>九、泛型</h1><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>主要有以下四个作用：</p>
<ul>
<li><strong>泛化</strong>：同样编写的代码可以被很多不同类型的对象所重用，提供代码的泛化能力。</li>
<li><strong>类型安全</strong>：提供编译期的类型安全检查机制，允许程序员在编译时检测到非法的类型。</li>
<li><strong>减少强制转换</strong>：泛型可以消除源代码中的许多强制类型转换，这样可以使代码更加可读，并减少出错的机会。</li>
</ul>
<blockquote>
<p><code>泛型</code>相当于把类型也参数化了！</p>
</blockquote>
<h2 id="9-1-泛型类-泛型方法-泛型接口"><a href="#9-1-泛型类-泛型方法-泛型接口" class="headerlink" title="9.1 泛型类 &amp; 泛型方法 &amp; 泛型接口"></a>9.1 泛型类 &amp; 泛型方法 &amp; 泛型接口</h2><ul>
<li><p><strong>泛型类</strong>：在类名后面用<code>&lt; &gt;</code>包裹一个或者多个大写字母（类型参数），该参数可以表示任意类型。在类中凡是可以使用类型的地方都可以使用该泛型声明。</p>
<blockquote>
<p>泛型的类型参数只能是类类型（如<code>Integer</code>），不能是简单&#x2F;基本类型（如<code>int</code>）。可以<code>List&lt;int []&gt;</code>! 因为数组在Java中是一个对象而不是基本类型。</p>
</blockquote>
</li>
<li><p><strong>泛型方法</strong>：这个方法可以定义在泛型类中，可以定义在普通类中，类型参数需要放在方法修饰符（如<code>public</code>  和 <code>static</code>）后面，在返回值类型前面。在方法的返回值、传入参数、方法体中可以使用该泛型类型。</p>
<blockquote>
<p>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</p>
<p>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类和泛型方法举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPair</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPair</span><span class="params">(T first, T second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">    <span class="comment">// 这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 泛型方法举例1</span></span><br><span class="line">    <span class="comment">// 在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">    <span class="comment">// 如果省略&lt;T&gt;将报错，因为静态成员/方法中不能使用类中声明的泛型类型参数</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 泛型方法举例2</span></span><br><span class="line">    <span class="comment">// 获取中间的传入参数（静态方法中如果要使用泛型，必须将静态方法也定义成泛型方法。）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; S <span class="title function_">getMiddle</span><span class="params">(S... num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num[num.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用举例</span></span><br><span class="line">MyPair&lt;String&gt; pair = <span class="keyword">new</span> <span class="title class_">MyPair</span>&lt;&gt;(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> MyPair.getMiddle(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Bob&quot;</span>);	<span class="comment">// 方法调用中会做泛型推断，所以可以不需要指明类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">f</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="string">&quot;asd&quot;</span>); <span class="comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">c</span> <span class="operator">=</span> Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">add</span><span class="params">(T x,T y)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>泛型接口</strong>：泛型接口与泛型类的定义及使用基本相同。当实现泛型接口的类，未传入泛型实参（具体的类型）时，需要把泛型的声明也一起加到类中，否则编译器将报错；在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个实现泛型接口的类（未传入泛型实参）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitGenerator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个实现泛型接口的类（传入泛型实参）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitGenerator</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Pear&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-2-泛型与继承"><a href="#9-2-泛型与继承" class="headerlink" title="9.2 泛型与继承"></a>9.2 泛型与继承</h2><p><font color="red"><strong>原始类之间的继承关系不会映射到泛型类中</strong>！</font></p>
<p>假设存在一个<code>Cat</code>类是<code>Animal</code>的子类，以下转换是合法的（子类–&gt;父类）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1</span></span><br><span class="line">Cat[] cats = <span class="keyword">new</span> <span class="title class_">Cats</span>[<span class="number">10</span>];</span><br><span class="line">Animal[] animals = cats;</span><br></pre></td></tr></table></figure>

<p>但是下面的转换是非法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 2</span></span><br><span class="line">List&lt;Cat&gt; cats = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Animal&gt; animals = cats;    <span class="comment">// 非法！ 如果把animal声明成List&lt;? extends Animal&gt;就可以赋值了！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果上述操作合法，则animals指向cats集合</span></span><br><span class="line">animals.add(<span class="keyword">new</span> <span class="title class_">Animal</span>()); <span class="comment">// 合法</span></span><br><span class="line">cats.get(<span class="number">0</span>); <span class="comment">// 非法！因为cats的get方法要求返回一个Cat类型的对象，而不是它的父类对象（父类无法转成子类）</span></span><br></pre></td></tr></table></figure>

<h2 id="9-3-通配符类型"><a href="#9-3-通配符类型" class="headerlink" title="9.3 通配符类型"></a>9.3 通配符类型</h2><p>本章[9.2 泛型与继承](# 9.2 泛型与继承)中描述的问题将导致无法给下面的<code>print1</code>方法传入<code>List&lt;Cat&gt;</code>类型的变量，而只能是<code>List&lt;Animal&gt;</code>类型，所以需要通配符<code>?</code>。</p>
<p><em>通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</em></p>
<ul>
<li><p>非限定通配符<code>&lt;?&gt;</code>，表示未知类型，此处的<code>?</code>和<code>Number</code>、<code>String</code>、<code>Integer</code>一样都是一种实际的类型，可以把<code>?</code>看成所有类型的父类，是一种真实的类型。</p>
<blockquote>
<p>当具体类型不确定的时候，这个通配符就是<code>?</code>；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能，那么可以用<code>?</code>通配符来表未知类型。</p>
<p>可以把List<String>, List<Integer>赋值给List&lt;?&gt;，却不能把List<String>赋值给List<Object>。</p>
</blockquote>
</li>
<li><p>带上限的通配符<code>&lt;? extends T&gt;</code>，表示可以传递<code>T</code>类型及其子类的<strong>赋值</strong>，<strong>只读不写</strong>（读取出来的内容值通过引用赋值得来的），例如实现一个支持对任何Animal的打印程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能声明成public void print1(List&lt;Animal&gt; animalList)因为泛型类之间不具有继承关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;? extends Animal&gt; animalList)</span> &#123;</span><br><span class="line">	<span class="comment">// animalList可以装任何Aminal及其子类</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; animalList.size(); i++) &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> animalList.get(i);</span><br><span class="line">        System.out.println(a);<span class="comment">// 编译正确，编译器可确定装的类型至少是Animal类型</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// animalList.set(new Dog());	// 编译错误，无法检验操作的安全性，万一实际装的是Cat类型就出错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">List&lt;Dog&gt; dogList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">dogList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">dogList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">print(dogList);</span><br></pre></td></tr></table></figure>
</li>
<li><p>带下限的通配符<code>&lt;? super T&gt;</code>，下界通配符，可以接受T类以及T的所有父类的<strong>赋值</strong>，在集合中使用时，可以add所有T类以及T子类的数据。<strong>只写</strong>（写也是有限制的，只能写T及其子类对象）<strong>不读</strong>（可以读出放入Object对象中），例如实现一个可以给容器填充任何动物的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeAllKinds</span><span class="params">(List&lt;? <span class="built_in">super</span> Animal&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Animal</span>());</span><br><span class="line">    <span class="comment">// list.add(new Object());	// 编译出错, 因为 ? super Animal 没有确定的根/父类</span></span><br><span class="line">    <span class="comment">// Animal d = list.get(0); // 编译出错，无法确定取出来的是不是Animal 传入的list中之前可能存的是Animal父类对象(如【标记】处的写法)</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 只能读到Object中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Animal&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();	<span class="comment">// 必须声明称Animal及其父类容器</span></span><br><span class="line"><span class="comment">// List&lt;Object&gt; list1 = new ArrayList&lt;&gt;();	// 这种也可以</span></span><br><span class="line"><span class="comment">// list1.add(new Object())	// 【标记】</span></span><br><span class="line">writeAllKinds(list1);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>综合使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用通配符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">(List&lt;Animal&gt; list)</span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extends 和 super 综合举例 java.util.Collections.copy()方法</span></span><br><span class="line"><span class="comment">// dest作为消费者只写不读(因为可以写入任何T的父类及子类类型的对象？，无法确定读出来的类型到底是什么)，src作为生产者只读不写（因为可以确定读取出来的类型至少是T类型），支持把T及其子类拷贝到T及其父类容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">srcSize</span> <span class="operator">=</span> src.size();</span><br><span class="line">    <span class="keyword">if</span> (srcSize &gt; dest.size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Source does not fit in dest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srcSize &lt; COPY_THRESHOLD ||</span><br><span class="line">        (src <span class="keyword">instanceof</span> RandomAccess &amp;&amp; dest <span class="keyword">instanceof</span> RandomAccess)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++)</span><br><span class="line">            dest.set(i, src.get(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListIterator&lt;? <span class="built_in">super</span> T&gt; di=dest.listIterator();</span><br><span class="line">        ListIterator&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; si=src.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++) &#123;</span><br><span class="line">            di.next();</span><br><span class="line">            di.set(si.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于PECS（extends作为生产者producer只读不写，super作为消费者consumer只写不读）参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31429205/article/details/103817506">Java 泛型，上界（生产者），下界（消费者）总结</a> 和 <a target="_blank" rel="noopener" href="http://ifeve.com/difference-between-super-t-and-extends-t-in-java/">泛型中? super T和? extends T的区别</a> 和<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20400700/answer/117464182">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？ - 胖君的回答 - 知乎 </a></p>
<h2 id="9-4-类型擦除"><a href="#9-4-类型擦除" class="headerlink" title="9.4 类型擦除"></a>9.4 类型擦除</h2><h3 id="9-4-1-什么是类型擦除"><a href="#9-4-1-什么是类型擦除" class="headerlink" title="9.4.1 什么是类型擦除"></a>9.4.1 什么是类型擦除</h3><blockquote>
<p>Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，最终泛型类型变成原始类型。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码（<code>class</code>文件）中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p>
</blockquote>
<blockquote>
<p>类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</p>
</blockquote>
<p>下面的代码可以证明Java的类型擦除机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; sList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">sList.add(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">List&lt;Integer&gt; iList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">iList.add(<span class="number">123</span>);</span><br><span class="line"><span class="comment">// 验证class是否相同，输出为 true （两者在编译后都变成了原始类型List）</span></span><br><span class="line">System.out.println(sList.getClass() == iList.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利反射机制验证，绕过编译检查，输出123 456</span></span><br><span class="line">iList.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class).invoke(iList, <span class="string">&quot;456&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iList.size(); i++) &#123;</span><br><span class="line">    System.out.println(iList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4-2-类型擦除引起的问题及解决方法"><a href="#9-4-2-类型擦除引起的问题及解决方法" class="headerlink" title="9.4.2 类型擦除引起的问题及解决方法"></a>9.4.2 类型擦除引起的问题及解决方法</h3><h4 id="9-4-2-1-自动类型转换"><a href="#9-4-2-1-自动类型转换" class="headerlink" title="9.4.2.1 自动类型转换"></a>9.4.2.1 自动类型转换</h4><p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。如<code>## 9.1</code>部分的代码将会变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(Object first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">MyPair&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">MyPair</span>&lt;&gt;();</span><br><span class="line">p.setFirst(<span class="string">&quot;Tom&quot;</span>);	<span class="comment">// JAVA会把String强转成Object</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();  <span class="comment">// JAVA会把Object强转成String</span></span><br></pre></td></tr></table></figure>

<p>此时对<code>getFirst</code>和<code>setFirst</code>进行调用时，将会对返回&#x2F;传入的类进行强制类型转换。</p>
<h4 id="9-4-2-2-类型擦除与多态的冲突"><a href="#9-4-2-2-类型擦除与多态的冲突" class="headerlink" title="9.4.2.2 类型擦除与多态的冲突"></a>9.4.2.2 类型擦除与多态的冲突</h4><p>假设有这样一个泛型类和他的一个子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&lt;Date&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.setValue(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">// student.setValue(new Object()); // 编译报错</span></span><br></pre></td></tr></table></figure>

<p>在子类中重写了父类的两个方法，但实际上，类型擦除后，父类的的泛型类型全部变为了原始类型<code>Object</code>，而在子类中却是<code>Date</code>类型，根本就没有这样的一个子类继承自父类的<code>Object</code>类型参数的方法，所以这变成了<del>方法的重载</del>(重载要求返回类型相同，所以getValue也不是重载)而不是重写！</p>
<blockquote>
<p>可是由于种种原因，虚拟机并不能将泛型类型变为<code>Date</code>，只能将类型擦除掉，变为原始类型<code>Object</code>。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。</p>
</blockquote>
<p><strong>好在编译器会自己生成的桥方法，桥方法的参数类型都是<code>Object</code>，在自动生成的桥方法中会调用我们重载的方法。</strong></p>
<p>参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/hao_yan_bing/article/details/89447792">Java泛型中的桥方法(Bridge Method)</a></p>
<h4 id="9-4-3-泛型与数组"><a href="#9-4-3-泛型与数组" class="headerlink" title="9.4.3 泛型与数组"></a>9.4.3 泛型与数组</h4><p>Java中不允许创建泛型数组，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;[<span class="number">10</span>];	<span class="comment">// 编译报错！因为类擦除后，将可以[]里面放任何Object类型</span></span><br><span class="line">List&lt;Integer&gt;[] list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>];	<span class="comment">// 编译不报错但是这样写不安全，相当于绕过了编译器的类型检查</span></span><br></pre></td></tr></table></figure>

<h2 id="9-5-参考资料"><a href="#9-5-参考资料" class="headerlink" title="9.5 参考资料"></a>9.5 参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1033693">10 道 Java 泛型面试题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuqinglong/p/9456193.html">Java泛型类型擦除以及类型擦除带来的问题</a></li>
</ul>
<h1 id="十、注解"><a href="#十、注解" class="headerlink" title="十、注解"></a>十、注解</h1><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">注解 Annotation 实现原理与自定义注解例子</a></p>
<h1 id="十一、特性"><a href="#十一、特性" class="headerlink" title="十一、特性"></a>十一、特性</h1><h2 id="Java-各版本的新特性"><a href="#Java-各版本的新特性" class="headerlink" title="Java 各版本的新特性"></a>Java 各版本的新特性</h2><h3 id="1-JDK1-8新特性"><a href="#1-JDK1-8新特性" class="headerlink" title="1 JDK1.8新特性"></a>1 JDK1.8新特性</h3><p><strong>【Lambda表达式】</strong></p>
<p>它支持只有一个方法的类或者接口，可以大大简化代码量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">Comparator&lt;Integer&gt; cpt2 = (x,y) -&gt; Integer.compare(x,y);</span><br></pre></td></tr></table></figure>

<p><strong>【接口中支持默认方法和静态方法实现】</strong></p>
<p>在接口中可以使用default和static关键字来修饰接口中定义的普通方法。因为在JDK1.8中很多接口会新增方法，为了保证1.8向下兼容，否则修改所有实现了该接口的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">default</span>  String <span class="title function_">getName</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="string">&quot;zhangsan&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">getName2</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="string">&quot;zhangsan&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> implement MyInterface &#123;</span><br><span class="line">    <span class="comment">// 无需实现接口中的默认/静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数式接口</strong></p>
<p>只有一个方法的接口，被声明为函数式接口 <code>@FunctionalInterface</code>，可以很好地支持lambda表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GreetingService</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt; System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">greetService1.sayMessage;</span><br></pre></td></tr></table></figure>

<p><strong>方法引用和构造器调用</strong></p>
<p>jdk1.8提供了另外一种调用方式<code>::</code>，当 你 需 要使用方法引用时 ， 目 标引用放在分隔符<code>::</code>前 ，方法的名称放在 后面 ，即<code>ClassName::methodName</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实体类User和它的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// User工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFactory</span> &#123;</span><br><span class="line">    User <span class="title function_">get</span><span class="params">(String name, String sex)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="type">UserFactory</span> <span class="variable">uf</span> <span class="operator">=</span> User::<span class="keyword">new</span>;	<span class="comment">// 方法引用</span></span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> uf.get(<span class="string">&quot;ww&quot;</span>, <span class="string">&quot;man&quot;</span>);	<span class="comment">// Java编译器会自动根据UserFactory.get方法的签名来选择合适的构造函数。</span></span><br></pre></td></tr></table></figure>

<p><strong>Stream API</strong></p>
<p>流是Java API的新成员，它允许我们以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。就现在来说，我们可以把它们看成遍历数据集的高级迭代器。此外，流还可以透明地并行处理，也就是说我们不用写多线程代码了。</p>
<p><strong>新时间日期API</strong></p>
<p><code>LocalDate </code>| <code>LocalTime </code>| <code>LocalDateTime </code>新的日期API都是不可变的，更使用于多线程的使用环境中。</p>
<h3 id="2-JDK1-7-新特性"><a href="#2-JDK1-7-新特性" class="headerlink" title="2 JDK1.7 新特性"></a>2 JDK1.7 新特性</h3><p><strong>New highlights in Java SE 7</strong>  </p>
<ol>
<li>Strings in Switch Statement</li>
<li>Type Inference for Generic Instance Creation</li>
<li>Multiple Exception Handling</li>
<li>Support for Dynamic Languages</li>
<li>Try with Resources</li>
<li>Java nio Package</li>
<li>Binary Literals, Underscore in literals</li>
<li>Diamond Syntax</li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17">Difference between Java 1.8 and Java 1.7?</a></li>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/19345.html">Java 8 特性</a></li>
</ul>
<h2 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h2><ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持<strong>自动垃圾回收</strong>，而 C++ 需要手动回收。</li>
<li>Java <strong>不支持多重继承</strong>，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php">What are the main differences between Java and C++?</a></p>
<h2 id="JRE-or-JDK"><a href="#JRE-or-JDK" class="headerlink" title="JRE or JDK"></a>JRE or JDK</h2><ul>
<li>JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。</li>
<li>JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境（包含JRE）。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。</li>
</ul>
<h1 id="十二、IO"><a href="#十二、IO" class="headerlink" title="十二、IO"></a>十二、IO</h1><p>参考 </p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112810033">BIO NIO AIO区别 - 心有小夕的文章 - 知乎 </a></p>
<p> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/115912936">100%弄明白5种IO模型 - 勤劳的小手的文章 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/486b0965c296">聊聊Linux 五种IO模型</a> 【推荐阅读】</p>
<h2 id="1-操作系统的五大IO模型"><a href="#1-操作系统的五大IO模型" class="headerlink" title="1 操作系统的五大IO模型"></a>1 操作系统的五大IO模型</h2><p>主要分为阻塞IO、非阻塞IO、多路复用IO、信号驱动IO、异步IO，<strong>前四个为同步IO模型</strong>。</p>
<blockquote>
<p>在IO模型里面如果请求方从发起请求到数据最后完成的这一段过程中都需要自己参与，那么这种我们称为<strong>同步请求</strong>；</p>
<p>反之，如果应用发送完指令后就不再参与过程了，只需要等待最终完成结果的通知，那么这就属于<strong>异步请求</strong>。</p>
<p><font color="red">同步I&#x2F;O是指I&#x2F;O函数的返回时刻和数据收发完成的<strong>时刻不一致</strong>，同步则为一致的。</font></p>
</blockquote>
<h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>阻塞IO是指在调用一个IO函数时，会由于无法成功获取到数据&#x2F;发送数据（因为内核还没准备好）而阻塞等待，等待过程中应用程序也是阻塞的，无法执行其他代码。</p>
<p>以<code>socket.recv()/read()</code>为例：</p>
<p><img src="/images/image-20210216210541646.png" alt="image-20210216210541646"></p>
<p>该函数面临两个阻塞过程：</p>
<ul>
<li>等待数据：底层的报文可能未接收完整（如一个UDP分组被IP分包，还未递交完成；TCP分组失序等）</li>
<li>将数据从内核拷贝到用户空间：因为应用程序只能访问用户内存，无法访问内核内存。</li>
</ul>
<h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>非阻塞I&#x2F;O 不管是否成功获取&#x2F;发送数据，都会立马获取结果，如果没有成功获取&#x2F;发送数据的话、则可以选择不间断的循环重试，但是我们整个应用程序不会实现阻塞。</p>
<p>以<code>socket.readfrom()</code>为例：</p>
<p><img src="/images/image-20210216211744016.png" alt="image-20210216211744016"></p>
<p>在没有数据准备好时，函数将直接返回，应用程序可以继续选择做其它事情，之后再继续尝试<code>readfrom()</code>来读取数据，直到读取成功（在把内核数据拷贝到用户空间时还是会阻塞）。</p>
<blockquote>
<p>相比于阻塞IO来说，非阻塞IO可能增加响应时延、降低吞吐量，但是可以同时执行其他任务。</p>
</blockquote>
<h3 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h3><p><strong>为什么需要多路复用IO？</strong></p>
<p>如果采用传统的阻塞&#x2F;非阻塞IO模型：</p>
<ul>
<li>阻塞IO：如果服务端面临大量客户端连接，需要创建大量线程来处理连接；当对应连接上暂时没有数据可读，线程需要阻塞在read上，造成资源浪费。</li>
<li>非阻塞IO：非阻塞模型下也同样需要大量线程高频率轮训读取数据，服务器压力巨大！</li>
</ul>
<p><img src="/images/image-20210216215041849.png" alt="image-20210216215041849"></p>
<p><strong>多路复用IO的基本思想？</strong></p>
<p>由一个线程监控多个网络请求（我们后面将称为fd文件描述符，linux系统把所有网络请求以一个fd来标识），这样就可以<strong>只需要一个或几个线程就可以完成数据状态询问的操作</strong>，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO复用模型的思路。</p>
<p><img src="/images/image-20210216220514814.png" alt="image-20210216220514814"></p>
<p>如上图所示：询问线程利用<code>select</code>操作（可以是阻塞&#x2F;非阻塞的）可以同时监控多个fd（网络IO），当有网络IO可操作时，则分配对应的处理线程进行IO操作（读取&#x2F;发送等），这样可以大大减少系统压力。</p>
<p>以利用<code>select</code>监控多个套接字读取数据为例：</p>
<p><img src="/images/image-20210216220849469.png" alt="image-20210216220849469"></p>
<blockquote>
<p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在<strong>同一个线程内同时处理多个IO请求的目的</strong>。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>
</blockquote>
<h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p>多路复用IO模型实现了一个线程监控多个网络IO的功能，但是其中的<code>select</code>机制要求应用程序不断轮训以实现对多个FD的及时监控。大部分时候可能轮训都是无效的，于是产生了信号驱动的IO模型——当<strong>FD可操作（有数据读取、缓存区空闲可以发数据）时主动通知应用程序！</strong></p>
<p><img src="/images/image-20210216221903896.png" alt="image-20210216221903896"></p>
<p>在信号驱动的IO模型下，应用程序通过调用<code>sigaction</code>和内核中的网络IO建立信号联系（注册一个信号处理函数到内核中）后立即返回，当内核准备好数据&#x2F;准备好缓冲区时，利用信号通知应用程序（调用应用程序的信号处理函数），应用程序再调用<code>recvfrom/send</code>函数来进行下一步操作（读取&#x2F;发送数据）。</p>
<p><img src="/images/image-20210216222557043.png" alt="image-20210216222557043"></p>
<p>这种是可以避免大量无效的轮训，在发起对各个FD的监控请求后只需等待通知即可。</p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>信号驱动的IO模型虽然解决了<code>select</code>机制中大量无效轮训的问题，但是依旧需要执行两个步骤才能完成IO操作，如在读取数据时，应用程序首先需要接受来自内核的信号，然后再主动调用<code>readfrom</code>函数来读取内核中的数据。</p>
<p>为了实现一劳永逸的操作，异步IO模型诞生了——应用只需要向内核发送一个read请求 &#x2F; send请求+待发送的数据，告诉内核它要读取&#x2F;发送数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪（如果是send请求则为数据发送完毕），内核会主动把数据从内核复制到用户空间（如果是send请求则是把数据从用户空间拷贝到内核空间），等所有操作都完成之后，内核会发起一个通知（回调）告诉应用（如果是read请求则在通知中将携带接收到的数据），我们称这种模式称为异步IO模型。</p>
<p><img src="/images/image-20210216223414370.png" alt="image-20210216223414370"></p>
<blockquote>
<p>异步IO模型 与 信号驱动模型的主要区别在于：</p>
<ul>
<li>信号驱动IO只是由内核通知我们何时可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成（数据在内核与用户空间之间拷贝完成了）。</li>
<li>信号驱动IO的两个阶段一个非阻塞（获取通知）、一个阻塞（内核——用户空间之间的数据拷贝），而异步IO的两个阶段都是非阻塞的。</li>
</ul>
</blockquote>
<p>以<code>readfrom</code>为例：</p>
<p><img src="/images/image-20210216223620975.png" alt="image-20210216223620975"></p>
<h3 id="五大IO模型对比"><a href="#五大IO模型对比" class="headerlink" title="五大IO模型对比"></a>五大IO模型对比</h3><p><img src="/images/5Qj6BiZVf0RWCRWYnl30Tg" alt="img"></p>
<p>（1）阻塞 I&#x2F;O 模型：阶段一和阶段二用户进程都处于阻塞状态，效率最低，适用于并发量低的小型网站，是Java BIO 的基础；</p>
<p>（2）非阻塞 I&#x2F;O 模型：阶段一用户进程处于非阻塞态，但应用进程需不断轮询内核空间数据是否准备好，消耗大量 CPU 时间；阶段二用户进程处于非阻塞态；</p>
<p>（3）I&#x2F;O 复用模型：阶段一和阶段二用户进程都处于阻塞状态，但其以较少的代价同时监听多个 文件描述符，效率较高，适用于并发高的大中型网站，Java NIO 是实现 I&#x2F;O 复用模型的基础；</p>
<p>（4）信号驱动 I&#x2F;O 模型：阶段一用户进程处于非阻塞态，阶段二用户进程处于阻塞态，目前应用较少；</p>
<p>（5）异步 I&#x2F;O 模型：阶段一和阶段二用户进程都处于非阻塞状态，效率最高，但异步 I&#x2F;O 模型在 Linux 2.6 版本才被引入，到现在仍未成熟。</p>
<h2 id="2-操作系统的select、poll、epoll机制"><a href="#2-操作系统的select、poll、epoll机制" class="headerlink" title="2 操作系统的select、poll、epoll机制"></a>2 操作系统的select、poll、epoll机制</h2><p><code>select</code>、<code>poll</code>、<code>epoll</code>实际上是实现 [多路复用IO模型](# 多路复用IO) 的三种系统调用，本质都是同步IO（因为在监控到读写事件后，依旧需要用阻塞函数read&#x2F;write来进行同步阻塞读写）。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><strong>基本原理</strong>：监控多个FD，底层采用bitmap记录每个FD的状态，最大可监控1024&#x2F;2048个FD（从效率上考虑、所以做了限制）。每次监控需要遍历所有FD（时间复杂度<code>O(N)</code>），获取结果后，还需要用户对所有FD挨个判断是否为有事件的FD，又需要遍历一遍<code>O(N)</code>。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>拷贝</strong>：每次调用select，都需要把监视对象（FD集合）传递给操作系统，即把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大。（见代码示例【标记点1】）</li>
<li><strong>遍历</strong>：同时每次调用select都需要遍历所有fd，这个开销在fd很多时也很大。（见代码示例【标记点2】）</li>
<li><strong>数量限制</strong>：select支持的文件描述符数量太小了，默认是1024（<code>linux/posix_types.h</code>中宏定义的值）</li>
</ul>
<p><strong>底层原理</strong>：</p>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63179839">epoll的本质</a></p>
<p>在调用select时，会把当前进程放入所有需要监控的套接字的等待队列中（用户空间–&gt;内核空间），网卡收到数据后利用DMA将数据放到缓存区后，触发CPU中断，CPU唤醒对应套接字的等待线程（等待队列–&gt;工作队列）。</p>
<p><img src="https://pic1.zhimg.com/80/v2-85dba5430f3c439e4647ea4d97ba54fc_hd.jpg" alt="img"></p>
<p><strong>编码实例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	SOCKET s, sock;</span><br><span class="line">	socket_list sock_list;		<span class="comment">//套接字管理队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>, <span class="title">remote_addr</span>;</span></span><br><span class="line">	WSAData wsa;</span><br><span class="line">	<span class="type">char</span> *buf;</span><br><span class="line">	<span class="type">int</span> len, total_len, total_sendlen, retval;</span><br><span class="line">	<span class="type">int</span> BufLen;</span><br><span class="line">	<span class="type">int</span> BufFlag;   <span class="comment">//malloc是否申请成功的标志</span></span><br><span class="line">	fd_set readfds, writefds, exceptfds;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> arg;</span><br><span class="line"></span><br><span class="line">	packet_buf *head;</span><br><span class="line"></span><br><span class="line">	WSAStartup(<span class="number">0x101</span>, &amp;wsa);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//---------获取接收缓存大小------------------</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入单片接收缓存大小(0表示自适应大小)：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;BufLen);</span><br><span class="line">	<span class="keyword">if</span> (BufLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//需要空间较大时，使用malloc申请动态内存</span></span><br><span class="line">		buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(BufLen);</span><br><span class="line">		<span class="keyword">if</span> (buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;内存不够\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		BufFlag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		BufFlag = <span class="number">0</span>;</span><br><span class="line">		buf = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	ser_addr.sin_family = AF_INET;</span><br><span class="line">	ser_addr.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">	ser_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">	bind(s, (sockaddr*)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line"></span><br><span class="line">	listen(s, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	init_list(&amp;sock_list);</span><br><span class="line">	sock_list.MainSock = s;</span><br><span class="line"></span><br><span class="line">	total_len = <span class="number">0</span>;</span><br><span class="line">	total_sendlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置套接字为非阻塞状态</span></span><br><span class="line">	arg = <span class="number">1</span>;</span><br><span class="line">	ioctlsocket(sock_list.MainSock, FIONBIO, &amp;arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//清空各个队列</span></span><br><span class="line">		FD_ZERO(&amp;readfds);</span><br><span class="line">		FD_ZERO(&amp;writefds);</span><br><span class="line">		FD_ZERO(&amp;exceptfds);</span><br><span class="line">		<span class="comment">//把所有套接字加入队列</span></span><br><span class="line">		make_fdlist(&amp;sock_list, &amp;readfds);</span><br><span class="line">		make_fdlist(&amp;sock_list, &amp;writefds);</span><br><span class="line">		make_fdlist(&amp;sock_list, &amp;exceptfds);</span><br><span class="line"></span><br><span class="line">		retval = select(<span class="number">0</span>, &amp;readfds, &amp;writefds, &amp;exceptfds, <span class="literal">NULL</span>);<span class="comment">// 【标记点1】</span></span><br><span class="line">		<span class="keyword">if</span> (retval == SOCKET_ERROR) &#123;</span><br><span class="line">			retval = WSAGetLastError();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;select error %d\n&quot;</span>, retval);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//查看主套接字上是否产生新的连接</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(sock_list.MainSock, &amp;readfds)) &#123;</span><br><span class="line">			len = <span class="keyword">sizeof</span>(remote_addr);</span><br><span class="line">			sock = accept(sock_list.MainSock, (sockaddr*)&amp;remote_addr, &amp;len);</span><br><span class="line">			<span class="keyword">if</span> (sock == SOCKET_ERROR)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;accept a connection\n&quot;</span>);</span><br><span class="line">			insert_list(sock, &amp;sock_list);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//查看从接套接字的状态     </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;   <span class="comment">// 【标记点2】</span></span><br><span class="line">			<span class="keyword">if</span> (sock_list.sock_array[i].s == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			sock = sock_list.sock_array[i].s;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//收到数据包</span></span><br><span class="line">			<span class="keyword">if</span> (FD_ISSET(sock, &amp;readfds)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (BufFlag == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">//自适应大小，根据待接收大小决定缓冲大小</span></span><br><span class="line">					ioctlsocket(sock, FIONREAD, (<span class="type">unsigned</span> <span class="type">long</span> *)&amp;len);</span><br><span class="line">					<span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (buf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">							<span class="comment">//free(buf);</span></span><br><span class="line">							buf = <span class="literal">NULL</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len);</span><br><span class="line">						<span class="keyword">if</span> (buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">							<span class="built_in">printf</span>(<span class="string">&quot;没有足够内存\n&quot;</span>);</span><br><span class="line">							<span class="keyword">continue</span>;    <span class="comment">//没有取走数据，下一次还有select事件么？？？</span></span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">//接收数据</span></span><br><span class="line">						len = recv(sock, buf, len, <span class="number">0</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//使用固定大小缓存接收数据</span></span><br><span class="line">					buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(BufLen);</span><br><span class="line">					len = recv(sock, buf, BufLen, <span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">/*返回值为0说明另一端已经关闭连接</span></span><br><span class="line"><span class="comment">					必须将套接字从接收队列中取下来！否则不关闭就会不断有read事件。*/</span></span><br><span class="line">					closesocket(sock);</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;Recv返回0，关闭套接字%d！\n&quot;</span>, sock);</span><br><span class="line">					delete_list(sock, &amp;sock_list);</span><br><span class="line">					<span class="comment">//printf(&quot;recv0发生过 %d 次无法及时发出的现象\n&quot;, pending_count);</span></span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">					retval = WSAGetLastError();</span><br><span class="line">					<span class="comment">//为何recv返回WSAEWOULDBLOCK？？？？？-----------------待补充</span></span><br><span class="line">					<span class="keyword">if</span> (retval == WSAEWOULDBLOCK) &#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					closesocket(sock);</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;close a socket\n&quot;</span>);</span><br><span class="line">					delete_list(sock, &amp;sock_list);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//将接收数据写入缓冲队列中</span></span><br><span class="line">				add_buf(sock, &amp;sock_list, buf, len);</span><br><span class="line">				<span class="comment">//buf[len] = 0;</span></span><br><span class="line">				total_len += len;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;接收 %d 字节，累计接收 %d 字节\n&quot;</span>, len, total_len);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//套接字可写</span></span><br><span class="line">			<span class="keyword">if</span> (FD_ISSET(sock, &amp;writefds)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((head = check_buf(sock, &amp;sock_list)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">					retval = send(sock, head-&gt;buf, head-&gt;size, <span class="number">0</span>);</span><br><span class="line">					<span class="comment">//对方关闭连接或者发送出错</span></span><br><span class="line">					<span class="keyword">if</span> (retval &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">						retval = WSAGetLastError();</span><br><span class="line">						closesocket(sock);</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;send0 error code：%d, close a socket\n&quot;</span>, retval);</span><br><span class="line">						<span class="comment">//printf(&quot;相关变量信息buf地址 %p ,len: %d\n&quot;, buf, len);</span></span><br><span class="line">						delete_list(sock, &amp;sock_list);</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//默认发送成功则全部发送----待完善检测----？？？？？</span></span><br><span class="line">					total_sendlen += retval;</span><br><span class="line">					delete_buf(sock, &amp;sock_list);	<span class="comment">//发送成功后释放对应的缓冲区</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;发送 %d 字节，共发送 %d 字节\n&quot;</span>, retval, total_sendlen);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//套接字异常</span></span><br><span class="line">			<span class="keyword">if</span> (FD_ISSET(sock, &amp;exceptfds)) &#123;</span><br><span class="line">				closesocket(sock);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;sock is in exceptfds, close a socket\n&quot;</span>);</span><br><span class="line">				delete_list(sock, &amp;sock_list);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>和<code>select</code>类似，只是底层采用链表记录FD状态，突破监控FD的数量限制。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll主要使用以下第三个函数来解决<code>select</code>存在的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">__uint32_t</span> events;	<span class="comment">// 事件类型：如EPOLLIN/EPOLLOUT/EPOLLRDHUB/EPOLLET/EPOLLONESHOT分别表示 可读/可写/半关闭/水平触发/边缘触发 事件；如果要同时监控多种事件，可以采用或运算如 xxx.events = EPOLLIN|EPOLLOUT;</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> * ptr;</span><br><span class="line">    <span class="type">int</span> fd;	<span class="comment">// socket文件描述符</span></span><br><span class="line">    <span class="type">__uint32_t</span> u32;</span><br><span class="line">    <span class="type">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief 创建保存epoll文件描述符的保存空间(epoll例程).</span></span><br><span class="line"><span class="comment"> * @param size 向操作系统建议的大值</span></span><br><span class="line"><span class="comment"> * @return 成功返回epoll例程描述符，失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;	</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief 向epoll空间注册/消耗文件描述符</span></span><br><span class="line"><span class="comment"> * @param epfd epoll例程的描述符(epoll_create()创建的)</span></span><br><span class="line"><span class="comment"> * @param op EPOLL_CTRL_ADD/DEL/MOD 分别表示添加/删除/修改</span></span><br><span class="line"><span class="comment"> * @param fd 监视对象的socket文件描述符</span></span><br><span class="line"><span class="comment"> * @param event 监视对象的事件类型</span></span><br><span class="line"><span class="comment"> * @return 成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event * event)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief 和select功能类似</span></span><br><span class="line"><span class="comment"> * @param epfd epoll例程的描述符(epoll_create()创建的)</span></span><br><span class="line"><span class="comment"> * @param events [OUT]会被写入发生事件的文件描述符集合</span></span><br><span class="line"><span class="comment"> * @param maxevents events申请的大小</span></span><br><span class="line"><span class="comment"> * @param timeout 阻塞超时时间，-1表示等待到有事件发生为止</span></span><br><span class="line"><span class="comment"> * @return 成功返回events的有效大小(发生事件的文件描述符个数)，失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>增量式更新需要监控的FD</strong>：使用<code>epoll_ctrl()</code>将用户需要监控的FD和对应的事件放到内核的事件表中（由<code>epoll_create()</code>创建的epoll例程），这是一种<strong>增量式更新</strong>，无需和select一样每次都拷贝全部FD到内核中；</li>
<li><strong>红黑树存储监控FD+链表存储有事件的FD</strong>：所有FD在内核cache中以红黑树的形式存储，支持快速查找和删除、插入（避免重复添加）；在内核cache里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表用于存储准备就绪的事件，内核检测到有事件发生则自动将FD加入到链表中【回调机制】。</li>
</ul>
<blockquote>
<p>红黑树中每个成员由描述符值和所要监控的文件描述符指向的文件表项的引用等组成。</p>
</blockquote>
<ul>
<li><strong>只关注有事件的FD</strong>：当<code>epoll_wait()</code>调用时，仅仅观察list链表里有没有数据即可，有数据就返回（链表中的FD到写入到入参events中，list.size直接返回），没有数据就sleep，等到timeout时间到后即使链表没数据也返回。</li>
<li><strong>共享内存而不是拷贝</strong>：<code>epoll_wait()</code>返回时，将有事件的FD通过共享内存的方式传递到用户空间，无需拷贝。</li>
</ul>
<p><img src="/images/image-20210301194115914.png" alt="image-20210301194115914"></p>
<p>epoll有<strong>条件触发</strong>和<strong>边缘触发</strong>两种工作模式：</p>
<ul>
<li><strong>水平触发LT</strong>：当所监控的FD有读写事件时，epoll_wait()会通知处理程序去读写。如果处理程序<strong>未把缓存区的数据读完，则会一直通知</strong>，如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！</li>
<li><strong>边缘触发ET</strong>：当所监控的FD有读写事件时，epoll_wait()会通知处理程序去读写。如果处理程序未把缓存区的数据读完，直到FD<strong>有新的读写事件出现才会进行下一次通知</strong>，这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！！</li>
</ul>
<blockquote>
<p>使用场景：</p>
<ul>
<li><p>对于读事件而言，总体而言, 采用水平触发方式较好。应用程序在读取数据时，可能会一次无法读取全部数据，边沿触发在下一次可能不会触发。如果能够保证一次读取缓存的全部数据，可以采用边沿触发，效率更高（用户&#x2F;内核切换次数更少）, 但同时编程复杂度也高（先要判断是否有足够数据，不够则等待）。</p>
</li>
<li><p>对于写事件，一般采用边缘触发，因为频繁关注可写事件会大量消耗CPU。当客户端服务端采用短连接或者采用长连接但发送的数据量比较少时(例如: Redis), 采用水平触发即可。当客户端与服务端是长连接并且数据写入的量比较大时(例如: nginx), 采用边沿触发, 因为边沿触发效率更高。</p>
</li>
</ul>
</blockquote>
<h3 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h3><ul>
<li><p>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p>
</li>
<li><p>select低效是因为每次它都需要轮询，如果服务端比较少，且考虑代码兼容性（Windows Linux均支持），可以使用它。</p>
</li>
</ul>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1641172494287388070&wfr=spider&for=pc">彻底搞懂epoll高效运行的原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wk_bjut_edu_cn/article/details/80669310?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.control&dist_request_id=c8aa95a3-8152-43aa-bea8-55a97baf347a&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.control">socket中的epoll及I&#x2F;O复用总结</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jeakeven/p/5435916.html">IO多路复用之select、poll、epoll详解</a></li>
</ul>
<h2 id="3-JAVA提供的BIO、NIO、AIO模型"><a href="#3-JAVA提供的BIO、NIO、AIO模型" class="headerlink" title="3 JAVA提供的BIO、NIO、AIO模型"></a>3 JAVA提供的BIO、NIO、AIO模型</h2><p>JAVA提供的三种IO机制是对操作系统提供的IO模型的进一步封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。</p>
<h3 id="BIO（同步阻塞IO）"><a href="#BIO（同步阻塞IO）" class="headerlink" title="BIO（同步阻塞IO）"></a>BIO（同步阻塞IO）</h3><p>BIO 就是传统的 <a href="https://link.zhihu.com/?target=http://java.io/">java.io</a> 包，它是基于流模型实现的，交互的方式是<strong>同步、阻塞</strong>方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p>
<ul>
<li><strong>优点</strong>：它的有点就是代码比较简单、直观；</li>
<li><strong>缺点</strong>： I&#x2F;O 的效率和扩展性很低，容易成为应用性能瓶颈；服务端针对每一个连接都需要开启一个新线程来处理。</li>
<li><strong>适用场景</strong>：适合用在活动连接数较少的场景中。活动连接多的时候需要频繁切换线程。</li>
</ul>
<p>以TCP C&#x2F;S为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();	<span class="comment">// accept是阻塞操作</span></span><br><span class="line">                <span class="comment">// 创建新的处理线程</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> len;</span><br><span class="line">                        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                        <span class="comment">// 按字节流方式读取数据</span></span><br><span class="line">                        <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;	<span class="comment">// read是阻塞操作</span></span><br><span class="line">                            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">                    <span class="comment">// 周期性发送数据到服务端</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        socket.getOutputStream().write((<span class="string">&quot;msg from &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;!&quot;</span>).getBytes());	<span class="comment">// write是阻塞操作</span></span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_NUM; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终服务端打印日志：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msg from 20!</span><br><span class="line">msg from 21!</span><br><span class="line">msg from 20!</span><br><span class="line">msg from 22!</span><br><span class="line">msg from 21!</span><br><span class="line">msg from 23!</span><br><span class="line">msg from 22!</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>BIO适用于同时活动连接数较少的情况（如小于1000）。</p>
</blockquote>
<h3 id="NIO（同步非阻塞IO）"><a href="#NIO（同步非阻塞IO）" class="headerlink" title="NIO（同步非阻塞IO）"></a>NIO（同步非阻塞IO）</h3><p>NIO 是 Java 1.4 引入的 java.nio 包，提供了 <code>Channel</code>、<code>Selector</code>、<code>Buffer </code>等新的抽象，可以构建<strong>多路复用</strong>的、<strong>同步非阻塞</strong> IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</p>
<ul>
<li><strong>优点</strong>：性能更高，单个线程可以处理多个IO请求，减少线程间的切换。</li>
<li><strong>缺点</strong>：原生编程相对复杂。</li>
<li><strong>适用场景</strong>：适合用在存在大量活动连接时。</li>
</ul>
<p><strong>Buffer</strong></p>
<p>NIO面向缓冲区&#x2F;块而不是面向流，进行读写操作时都是和缓存区打交道而不是直接和流。</p>
<p>面向流的方式每次需要处理一格或者多个字节，而面向块则一次性可以处理一块数据（取决于buffer的大小），缓冲区的IO操作是由底层操作系统实现的，效率较高。</p>
<p><strong>Selector + Channel</strong></p>
<p>Selector用于使用单个线程处理多个通道。因此，它需要较少的线程来处理多个通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。（多路复用机制）</p>
<p>NIO 通过Channel（通道） 进行读写。通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</p>
<p><img src="/images/image-20210217001207875.png" alt="image-20210217001207875"></p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. serverSelector负责轮询是否有新的连接，服务端监测到新的连接之后，不再创建一个新的线程，</span></span><br><span class="line">        <span class="comment">// 而是直接将新连接绑定到clientSelector上，这样就不用 IO 模型中 1w 个 while 循环在死等</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">serverSelector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 2. clientSelector负责轮询连接是否有数据可读</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">clientSelector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 处理serverSelector中的事件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 对应IO编程中服务端启动</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">listenerChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">                listenerChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8888</span>));</span><br><span class="line">                listenerChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 监测是否有新的连接，这里的1指的是阻塞的时间为 1ms</span></span><br><span class="line">                    <span class="keyword">if</span> (serverSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="comment">// (1)</span></span><br><span class="line">                                    <span class="comment">// 每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector</span></span><br><span class="line">                                    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                                    clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                                    clientChannel.register(clientSelector, SelectionKey.OP_READ);	<span class="comment">// 要求监控读事件</span></span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    keyIterator.remove();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 处理clientSelector中的事件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为 1ms</span></span><br><span class="line">                    <span class="keyword">if</span> (clientSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                                    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// (3) 面向 Buffer</span></span><br><span class="line">                                    clientChannel.read(byteBuffer);</span><br><span class="line">                                    byteBuffer.flip();    <span class="comment">// 切换读写</span></span><br><span class="line">                                    System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    keyIterator.remove();</span><br><span class="line">                                    key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>NIO适合用在并发量大的情况下。</p>
<p>NIO底层基于epoll，原生编程相当复杂，一般采用Netty框架（基于NIO）来做。</p>
</blockquote>
<h3 id="AIO（异步非阻塞IO）"><a href="#AIO（异步非阻塞IO）" class="headerlink" title="AIO（异步非阻塞IO）"></a>AIO（异步非阻塞IO）</h3><p>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了<strong>异步非阻塞的 IO</strong> 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是<strong>基于事件和回调机制</strong>实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成（如数据已经从内核中拷贝到了用户空间&#x2F;数据已经内从内核发出去了），操作系统会通知相应的线程进行后续的操作。</p>
<blockquote>
<p>NS3中的Socket API就是一种AIO的机制。</p>
</blockquote>
<h2 id="4-Reactor（Netty使用的）IO-模型"><a href="#4-Reactor（Netty使用的）IO-模型" class="headerlink" title="4 Reactor（Netty使用的）IO 模型"></a>4 Reactor（Netty使用的）IO 模型</h2><p>针对传统传统阻塞I&#x2F;O服务模型的2个缺点，比较常见的有如下解决方案：</p>
<ul>
<li>基于I&#x2F;O复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</li>
<li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li>
</ul>
<h3 id="4-1-Reactor基本思想"><a href="#4-1-Reactor基本思想" class="headerlink" title="4.1 Reactor基本思想"></a>4.1 Reactor基本思想</h3><p><font color="red"><strong>I&#x2F;O复用结合线程池，这就是Reactor模式基本设计思想。</strong></font></p>
<p><img src="/images/image-20210713220604248.png" alt="image-20210713220604248"></p>
<p><strong>Reactor模式，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式</strong>。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I&#x2F;O多了复用统一监听事件，收到事件后分发(Dispatch给某进程)，是编写高性能网络服务器的必备技术之一。</p>
<h3 id="4-2-Reactor模型构成"><a href="#4-2-Reactor模型构成" class="headerlink" title="4.2 Reactor模型构成"></a>4.2 Reactor模型构成</h3><ul>
<li><p><strong>Reactor：</strong> Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人。</p>
</li>
<li><p><strong>Handlers</strong> ：处理程序执行I&#x2F;O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I&#x2F;O事件，处理程序执行非阻塞操作</p>
</li>
</ul>
<h3 id="4-3-Reactor模型实现"><a href="#4-3-Reactor模型实现" class="headerlink" title="4.3 Reactor模型实现"></a>4.3 Reactor模型实现</h3><p>根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现：</p>
<h4 id="4-3-1-单Reactor单线程"><a href="#4-3-1-单Reactor单线程" class="headerlink" title="4.3.1 单Reactor单线程"></a>4.3.1 单Reactor单线程</h4><p><img src="/images/image-20210713221140673.png" alt="image-20210713221140673"></p>
<p>其中，select是前面<strong>I&#x2F;O复用模型</strong>介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求，其他方案示意图类似。</p>
<p><strong>方案说明</strong></p>
<ul>
<li>Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发</li>
<li>如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</li>
<li>Handler会完成read-&gt;业务处理-&gt;send的完整业务流程</li>
</ul>
<p><strong>优点</strong></p>
<p> 模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</p>
<p><strong>缺点</strong></p>
<ul>
<li>性能问题：只有一个线程，无法完全发挥多核CPU的性能 Handler在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>可靠性问题：线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
</ul>
<p><strong>使用场景</strong></p>
<p> 客户端的数量有限，业务处理非常快速，比如Redis，业务处理的时间复杂度O(1)</p>
<h4 id="4-3-2-单Reactor多线程"><a href="#4-3-2-单Reactor多线程" class="headerlink" title="4.3.2 单Reactor多线程"></a>4.3.2 单Reactor多线程</h4><p><img src="/images/image-20210713221454439.png" alt="image-20210713221454439"></p>
<p><strong>方案说明</strong></p>
<ul>
<li>Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发</li>
<li>如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的续各种事件</li>
<li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</li>
<li>Handler只负责响应事件，不做具体业务处理，通过read读取数据后，会分发给后面的Worker线程池进行业务处理</li>
<li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li>
<li>Handler收到响应结果后通过send将响应结果返回给client</li>
</ul>
<p><strong>优点</strong></p>
<p> 可以充分利用多核CPU的处理能力</p>
<p><strong>缺点</strong></p>
<ul>
<li>多线程数据共享和访问比较复杂</li>
<li>Reactor承担所有事件的监听和响应，在单线程中运行，高并发场景下容易成为性能瓶颈</li>
</ul>
<h4 id="4-3-3-多Reactor多线程"><a href="#4-3-3-多Reactor多线程" class="headerlink" title="4.3.3 多Reactor多线程"></a>4.3.3 多Reactor多线程</h4><p>针对单Reactor多线程模型中，Reactor在单线程中运行，高并发场景下容易成为性能瓶颈，可以让Reactor在多线程中运行</p>
<p><img src="/images/image-20210713221624187.png" alt="image-20210713221624187"></p>
<p><strong>方案说明</strong></p>
<ul>
<li>Reactor主线程MainReactor对象通过select监控建立连接事件，收到事件后通过Acceptor接收，处理建立连接事件</li>
<li>Accepto处理建立连接事件后，MainReactor将连接分配Reactor子线程给SubReactor进行处理</li>
<li>SubReactor将连接加入连接队列进行监听，并创建一个Handler用于处理各种连接事件</li>
<li>当有新的事件发生时，SubReactor会调用连接对应的Handler进行响应</li>
<li>Handler通过read读取数据后，会分发给后面的Worker线程池进行业务处理</li>
<li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li>
<li>Handler收到响应结果后通过send将响应结果返回给client</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理</li>
<li>父线程与子线程的数据交互简单，Reactor主线程只需要把新连接传给子线程，子线程无需返回数据</li>
</ul>
<p>这种模型在许多项目中广泛使用，包括Nginx主从Reactor多进程模型，Memcached主从多线程，Netty主从多线程模型的支持。</p>
<h3 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h3><p>3种模式可以用个比喻来理解： 餐厅常常雇佣接待员负责迎接顾客，当顾客入坐后，侍应生专门为这张桌子服务</p>
<ul>
<li>单Reactor单线程： 接待员和侍应生是同一个人，全程为顾客服务</li>
<li>单Reactor多线程： 1个接待员，多个侍应生，接待员只负责接待</li>
<li>主从Reactor多线程： 多个接待员，多个侍应生</li>
</ul>
<p>Reactor模式具有如下的优点：</p>
<ul>
<li>响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的</li>
<li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销；</li>
<li>可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源</li>
<li>可复用性，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ul>
<blockquote>
<p>Reactor是非阻塞同步IO模型！！！</p>
</blockquote>
<h1 id="十三、集合"><a href="#十三、集合" class="headerlink" title="十三、集合"></a>十三、集合</h1><h3 id="1-HashMap实现原理"><a href="#1-HashMap实现原理" class="headerlink" title="1 HashMap实现原理"></a>1 HashMap实现原理</h3><p>主要从<strong>底层存储结构、构造方法、<code>PUT()</code>方法、<code>GET()</code>方法、扩容机制</strong>几个方面来说。</p>
<p><font color="blue"><strong>——————JKD 1.8以前———————–</strong></font></p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>采用数组+链表的方式来存储键值对（拉链法解决哈希冲突）。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>构造方法中主要涉及两个参数：</p>
<ul>
<li>initialCapacity：初始容量，值HashMap中能存储的最多的键值对数量，必须是2^N（因为后续是采用&amp;来进行下标运算而不是%），默认16</li>
<li>loadFactor：加载因子，用于扩容，loadFactor * initialCapacity就是扩容阈值，默认0.75f</li>
</ul>
<h4 id="PUT-方法"><a href="#PUT-方法" class="headerlink" title="PUT()方法"></a><code>PUT()</code>方法</h4><p>往HashMap中插入元素主要分为以下几个步骤：</p>
<ul>
<li><p>利用<code>key.hashCode()</code>值计算一个<code>hash</code>值（重新加入扰动，减少冲突）</p>
</li>
<li><p>利用<code>hash</code>值计算下标（<code>hash &amp; table.size - 1</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// 做四次移位亦或</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.8中只做了一次 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果数组下标对应位置没有元素则直接插入；否则遍历上面的链表，如果找到相同（<code>hash值相等 &amp;&amp; (key地址相等 || equals相同)</code>）的key则替换旧value，如果没有则将新元素<strong>插入链表头部</strong></p>
</li>
</ul>
<h4 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET()方法"></a><code>GET()</code>方法</h4><ul>
<li>利用<code>key.hashCode()</code>值计算一个<code>hash</code>值（重新加入扰动，减少冲突）</li>
<li>利用<code>hash</code>值计算下标（<code>hash &amp; table.size - 1</code>）</li>
<li>遍历该下标中的链表，直到找到相同的<code>key</code>（key.hash &#x3D;&#x3D; hash &amp;&amp; (key &#x3D;&#x3D; this.key || key.equals(this.key))）即可返回对应的<code>value</code></li>
</ul>
<blockquote>
<p>key为null时直接存在数组第一个位置。</p>
</blockquote>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>在<code>PUT()</code>方法中，如果在使用头插法插入新节点前，发现HashMap容量超过阈值，则需要先执行扩容，扩容的步骤如下：</p>
<ul>
<li>构造一个两倍大小的数组</li>
<li>遍历旧的数组，将上面的链表中的元素<strong>挨个</strong>迁移（重新计算下标值）到新数组中（旧下标为index，新下标为index或oldSize+index），同样采用头插法</li>
</ul>
<p><font color="red">容量超过1&lt;&lt;30后（即1073741824）则扩容不再增大两倍，直接保持为2^31-1（Integer.MAX_VALUE）不再改变。</font></p>
<p><font color="blue"><strong>—————————JKD 1.8以后————————–</strong></font></p>
<ul>
<li>构造方法不变。</li>
<li>底层结构改为采用<strong>数组+红黑树&#x2F;链表</strong>的形式（<strong>链表长度大于8则变成红黑树，红黑树节点数小于6则退化成链表</strong>）。</li>
<li>PUT方法中采用<strong>尾插法</strong>（如果链表还未变成红黑树） ，根据节点类型不同采用不同的插入方式</li>
<li>扩容机制为<strong>先插入，后扩容</strong>，和1.7相反；数据迁移方式为将链表&#x2F;红黑树（内部也含有双链表结构，数组大小必须大于64，否则只会扩容不会树化）拆分成两个单链表，<strong>一次性迁移</strong>两个单链表。</li>
</ul>
<h4 id="HashMap线程安全问题"><a href="#HashMap线程安全问题" class="headerlink" title="HashMap线程安全问题"></a>HashMap线程安全问题</h4><p><strong>数据丢失：</strong></p>
<ul>
<li><strong>并发赋值被覆盖：</strong> 在 <code>createEntry</code> 方法中，新添加的元素直接放在头部，使元素之后可以被更快访问，但如果两个线程同时执行到此处，会导致其中一个线程的赋值被覆盖。</li>
<li><strong>已遍历区间新增元素丢失：</strong> 当某个线程在 <code>transfer</code> 方法迁移时，其他线程新增的元素可能落在已遍历过的哈希槽上。遍历完成后，table 数组引用指向了 newTable，新增元素丢失。</li>
<li><strong>新表被覆盖：</strong> 如果 <code>resize</code> 完成，执行了 <code>table = newTable</code>，则后续元素就可以在新表上进行插入。但如果多线程同时 <code>resize</code> ，每个线程都会 new 一个数组，这是线程内的局部对象，线程之间不可见。迁移完成后<code>resize</code> 的线程会赋值给 table 线程共享变量，可能会覆盖其他线程的操作，在新表中插入的对象都会被丢弃。</li>
</ul>
<p><font color="red"><strong>死循环：</strong></font></p>
<p>HashMap在put的时候，插入的元素超过了阈值的范围就会触发扩容操作，如果多个线程同时在执行<code>transfer()</code>时可能成循环链表，导致在get时会出现死循环，所以HashMap是线程不安全的。</p>
<p><font color="blue">如何实现线程安全的HashMap呢？</font></p>
<ul>
<li><font color="green">调用<code>put()</code>&#x2F;<code>get()</code>等操作前加锁，所有map的所有操作共用一个锁。</font></li>
<li><font color="green">用<code>Collections.synchroizedMap(new HashMap&lt;&gt;())</code>得到线程安全的Map实例（内部对传入HashMap做包装，每次调用hashmap操作前都使用<code>synchronized</code>做加锁）</font></li>
<li><font color="green">使用线程安全的容器来替代如<code>HashTable</code>&#x2F;<code>ConcurrentHashMap</code></font></li>
</ul>
<h3 id="2-ConcurrentHashMap实现原理"><a href="#2-ConcurrentHashMap实现原理" class="headerlink" title="2 ConcurrentHashMap实现原理"></a>2 ConcurrentHashMap实现原理</h3><p>HashMap在并发是存在数据覆盖、数据丢失（扩容时插入元素）、循环链表等问题（两个线程同时扩容）等安全问题，所以需要一个支持线程安全的容器：<code>ConcurrentHashMap</code>！</p>
<p>主要从<strong>底层存储结构、构造方法、<code>PUT()</code>方法、<code>GET()</code>方法、扩容机制</strong>几个方面来说。</p>
<p>—————-JDK 1.8 以前—————-</p>
<h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p>采用Segment数组来存储（JDK1.7中HashMap的数组+链表的结构），相当于是数组嵌套数组，一个Segment支持一个线程访问（分段锁，Segment继承了<code>ReentrantLock</code>）。</p>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><p>构造方法中主要涉及两个参数：</p>
<ul>
<li><p>initialCapacity：初始容量，值HashMap中能存储的最多的键值对数量，必须是2^N（因为后续是采用&amp;来进行下标运算而不是%），默认16</p>
</li>
<li><p>loadFactor：加载因子，用于扩容，loadFactor * initialCapacity就是扩容阈值，默认0.75f</p>
</li>
<li><p>concurrencyLevel：并发级别（Segment数组的长度），必须是2^N，默认16</p>
</li>
</ul>
<h4 id="PUT-方法-1"><a href="#PUT-方法-1" class="headerlink" title="PUT()方法"></a><code>PUT()</code>方法</h4><ul>
<li>利用<code>key.hashCode()</code>值计算一个<code>hash</code>值（重新加入扰动，减少冲突）</li>
<li>利用<code>hash</code>值计算Segment下标值<code>j</code></li>
<li>如果对应Segment数组下标<code>j</code>没有元素则创建并CAS自旋写入Segment元素（拷贝s0）</li>
<li>先尝试非阻塞对Segment<strong>加锁</strong>，多次失败后开始阻塞加锁，<strong>插入新节点</strong>（过程和HashMap一致），<strong>解锁</strong></li>
</ul>
<h4 id="GET-方法-1"><a href="#GET-方法-1" class="headerlink" title="GET()方法"></a><code>GET()</code>方法</h4><p>get方法<strong>无需加锁</strong>，只需利用哈希值计算两次下标后遍历链表即可。读操作只能保证<strong>弱一致性</strong>（value采用volatile修饰，保证线程可见性）。</p>
<h4 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>支持多线程<strong>协助扩容</strong>，每个线程都会被分配到相应的迁移桶任务。</p>
<h4 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a><code>size()</code>方法</h4><ul>
<li>先不加锁，对所有Segment.size进行两次累加统计</li>
<li>如果两次累加统计结果一致则结果正确直接返回；不一致（尝试三次）则对每一个Segement加锁后再次统计即可得到正确值</li>
</ul>
<p>—————-JDK 1.8 以后—————-</p>
<ul>
<li><strong>底层结构</strong>：抛弃Segment结构，直接采用 数组+链表&#x2F;红黑树 的方式存储元素；</li>
<li>针对每一个数组元素上的链表&#x2F;红黑树进行加锁（<strong>粒度更细</strong>）；使用<em>CAS</em>+<code>synchronized</code>来保证并发安全性。</li>
</ul>
<h3 id="3-JDK1-8为什么使用红黑树？"><a href="#3-JDK1-8为什么使用红黑树？" class="headerlink" title="3 JDK1.8为什么使用红黑树？"></a>3 JDK1.8为什么使用红黑树？</h3><ul>
<li>使用红黑树，避免哈希冲突链表过长时影响插入&#x2F;查询的效率；红黑树节点小于6时退化成链表，降低红黑树维护成本</li>
<li><strong>AVL树是严格平衡</strong>的二叉树，深度比红黑树小，查找速度快，但是维护平衡（旋转）的代价更高、插入&#x2F;删除慢；红黑树插入&#x2F;删除效率比AVL树高（调整平衡最多需要两次旋转），性能相对折中，所以选红黑树。</li>
<li><strong>不用二叉查找树</strong>：因二叉查找树如果在key值递增或递减的情况下会退化成链表，查找效率低。</li>
<li><strong>不用B&#x2F;B+树</strong>：适合文件系统？减少IO次数</li>
</ul>
<h3 id="4-HashMap和HashTable的区别"><a href="#4-HashMap和HashTable的区别" class="headerlink" title="4 HashMap和HashTable的区别"></a>4 HashMap和HashTable的区别</h3><ul>
<li><p><strong>底层实现</strong>：两者底层实现相似，JDK1.8之后HashMap改用数组+红黑树，而HashTable依旧保持数组+链表</p>
</li>
<li><p><strong>线程安全性</strong>：HashMap线程不安全（可能造成数据丢失、循环链表、数据覆盖等问题），HashTable线程安全（所有方法均采用<code>syncronized</code>修饰）</p>
</li>
<li><p><strong>效率</strong>：HashTable效率低，因为每个操作都需要加解锁。</p>
</li>
<li><p><strong>哈希计算</strong>：HashMap会对key对象的<code>hashCode</code>重新进行<code>hash</code>（高16为亦或低16位），而HashTable直接使用<code>hashCode()</code>。</p>
</li>
<li><p><strong><code>null</code>键的支持</strong>：HashMap支持<code>null</code>键，而HashTable不支持。</p>
<blockquote>
<p>HashTable中计算元素下标时要用到<code>key.hashCode()</code>方法 ：<code>int hash = key.hashCode()</code>，比较对象是否相等要用到<code>key.equals()</code>方法，所以不允许key为空。</p>
<p>HashMap中计算元素下标时会对重新<code>hash(key)</code>， 其中内部如果发现<code>key==null</code>则返回0，且在调用<code>key.euqasl()</code>进行比较之前会先判断<code>key!=null</code>，所以可以支持<code>key</code>为<code>null</code>的情况。</p>
</blockquote>
</li>
<li><p><strong>迭代器</strong>：HashMap 的迭代器是 fail-fast 迭代器（迭代过程中如果modCount发生变化则报<code>ConcurrentModificationException</code>）;</p>
</li>
</ul>
<blockquote>
<p>Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</p>
</blockquote>
<h3 id="5-ArrayList和Vector原理"><a href="#5-ArrayList和Vector原理" class="headerlink" title="5 ArrayList和Vector原理"></a>5 ArrayList和Vector原理</h3><p><strong>ArrayList</strong></p>
<ul>
<li><strong>底层结构</strong>：数组<code>Object[]] elementData</code></li>
<li><strong>构造方法</strong>：只需传入<code>capacity</code>参数，默认大小为10</li>
<li><strong>扩容</strong>：每次添加元素前会检查空间是否足够，不够则调用<code>grow()</code>进行扩容：<ul>
<li>将源数组扩容1.5倍（<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>）</li>
<li>将旧数据拷贝到新数组中<code>Arrays.copyOf(elementData, newCapacity)</code></li>
</ul>
</li>
</ul>
<p><strong>Vector</strong></p>
<p>底层实现和<code>ArrayList</code>一致，只是所有方法前加了一个<code>synchronized</code>实现同步。</p>
<h3 id="6-ArrayList和LinkedList区别"><a href="#6-ArrayList和LinkedList区别" class="headerlink" title="6 ArrayList和LinkedList区别"></a>6 ArrayList和LinkedList区别</h3><ul>
<li>底层机构：</li>
<li>插入数据：</li>
<li>删除&#x2F;修改数据：</li>
</ul>
<h1 id="其它面试题"><a href="#其它面试题" class="headerlink" title="其它面试题"></a>其它面试题</h1><h3 id="1-Java和C-的区别？"><a href="#1-Java和C-的区别？" class="headerlink" title="1 Java和C++的区别？"></a>1 Java和C++的区别？</h3><ul>
<li><strong>指针</strong>：Java中没有指针，C++中有；</li>
<li><strong>多继承</strong>：Java不支持多继承（支持多接口实现），C++支持多继承；</li>
<li><strong>垃圾回收</strong>：Java有自动GC，C++需要显式释放内存。</li>
</ul>
<h3 id="2-ClassNotFoundException和-NoClassDefFoundError区别"><a href="#2-ClassNotFoundException和-NoClassDefFoundError区别" class="headerlink" title="2 ClassNotFoundException和 NoClassDefFoundError区别"></a>2 ClassNotFoundException和 NoClassDefFoundError区别</h3><h4 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a>ClassNotFoundException</h4><p>使用<code>Class.forName()/loadClass()/findSystemClass()</code>方法来动态加载类（传入全类名），如果该类的路径没有被找到，这个时候就会抛出<code>ClassNotFoundException</code>。该异常可以被用户捕获。</p>
<blockquote>
<p>编译时依赖的类（jar包）在运行环境机器中不存在（属于无法处理的Error，程序Crash）。</p>
</blockquote>
<h4 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h4><p>如果JVM或者Classloader实例尝试加载类(或者new创建对象)却找不到类的定义，要查找的类在编译时期是存在，运行期间却找不到该对象对应的类，这个时候就会导致<code>NoClassDeFoundError</code>错误。该错误不能被用户捕获。</p>
<blockquote>
<p>在生产环境出现的原因通常是由于依赖jar包多版本存在，或者jar包升级类或者方法不再提供。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.</li>
<li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"><i class="fa fa-tag"></i> 后端</a>
          
            <a href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> Java基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/09/23/SpringBoot%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" rel="next" title="SpringBoot实现自定义异常处理">
                <i class="fa fa-chevron-left"></i> SpringBoot实现自定义异常处理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">Java基础知识相关笔记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">0、面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">面向对象和面向过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">面向对象的三大特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">一、数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.1.</span> <span class="nav-text">浮点数的存储机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">包装类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="nav-number">3.3.</span> <span class="nav-text">缓存池</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81String"><span class="nav-number">4.</span> <span class="nav-text">二、String</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%A7%88"><span class="nav-number">4.1.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">4.2.</span> <span class="nav-text">不可变的好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-StringBuffer-and-StringBuilder"><span class="nav-number">4.3.</span> <span class="nav-text">String, StringBuffer and StringBuilder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-Pool"><span class="nav-number">4.4.</span> <span class="nav-text">String Pool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-String-%E2%80%9Cabc%E2%80%9D"><span class="nav-number">4.5.</span> <span class="nav-text">new String(“abc”)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%BF%90%E7%AE%97"><span class="nav-number">5.</span> <span class="nav-text">三、运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">5.1.</span> <span class="nav-text">参数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#float-%E4%B8%8E-double"><span class="nav-number">5.2.</span> <span class="nav-text">float 与 double</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.3.</span> <span class="nav-text">隐式类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch"><span class="nav-number">5.4.</span> <span class="nav-text">switch</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.</span> <span class="nav-text">四、关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-number">6.1.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">6.2.</span> <span class="nav-text">static</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81Object-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">五、Object 通用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%A7%88-1"><span class="nav-number">7.1.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals"><span class="nav-number">7.2.</span> <span class="nav-text">equals()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashCode"><span class="nav-number">7.3.</span> <span class="nav-text">hashCode()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals-%E5%92%8ChashCode-%E7%9A%84%E8%81%94%E7%B3%BB"><span class="nav-number">7.4.</span> <span class="nav-text">equals()和hashCode()的联系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toString-NaN"><span class="nav-number">7.5.</span> <span class="nav-text">toString()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clone-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">7.6.</span> <span class="nav-text">clone()&#x2F;深浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-cloneable"><span class="nav-number">7.6.1.</span> <span class="nav-text">1. cloneable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%B5%85%E6%8B%B7%E8%B4%9D-VS-%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">7.6.2.</span> <span class="nav-text">2. 浅拷贝 VS 深拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">7.6.3.</span> <span class="nav-text">3. 如何实现深拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF"><span class="nav-number">8.</span> <span class="nav-text">六、继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">8.1.</span> <span class="nav-text">访问权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.2.</span> <span class="nav-text">抽象类与接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">8.2.1.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.2.2.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83"><span class="nav-number">8.2.3.</span> <span class="nav-text">比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9"><span class="nav-number">8.2.4.</span> <span class="nav-text">使用选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super"><span class="nav-number">8.3.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD"><span class="nav-number">8.4.</span> <span class="nav-text">重写与重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89"><span class="nav-number">8.4.1.</span> <span class="nav-text">重写（Override）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89"><span class="nav-number">8.4.2.</span> <span class="nav-text">重载（Overload）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">8.5.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81"><span class="nav-number">8.5.1.</span> <span class="nav-text">JAVA如何实现多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E8%B0%83%E7%94%A8%E7%9A%84%E6%98%AF%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-number">8.5.2.</span> <span class="nav-text">JVM如何确定调用的是子类方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%8F%8D%E5%B0%84"><span class="nav-number">9.</span> <span class="nav-text">七、反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">9.1.</span> <span class="nav-text">反射的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">9.2.</span> <span class="nav-text">反射的缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">9.3.</span> <span class="nav-text">反射的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">9.3.1.</span> <span class="nav-text">动态代理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%BC%82%E5%B8%B8"><span class="nav-number">10.</span> <span class="nav-text">八、异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB"><span class="nav-number">10.1.</span> <span class="nav-text">异常分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9B%B8%E5%85%B3%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">10.2.</span> <span class="nav-text">异常相关的关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">10.3.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="nav-number">11.</span> <span class="nav-text">九、泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-%E6%B3%9B%E5%9E%8B%E7%B1%BB-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">11.1.</span> <span class="nav-text">9.1 泛型类 &amp; 泛型方法 &amp; 泛型接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">11.2.</span> <span class="nav-text">9.2 泛型与继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="nav-number">11.3.</span> <span class="nav-text">9.3 通配符类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">11.4.</span> <span class="nav-text">9.4 类型擦除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">11.4.1.</span> <span class="nav-text">9.4.1 什么是类型擦除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-2-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">11.4.2.</span> <span class="nav-text">9.4.2 类型擦除引起的问题及解决方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-2-1-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">11.4.2.1.</span> <span class="nav-text">9.4.2.1 自动类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-2-2-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E4%B8%8E%E5%A4%9A%E6%80%81%E7%9A%84%E5%86%B2%E7%AA%81"><span class="nav-number">11.4.2.2.</span> <span class="nav-text">9.4.2.2 类型擦除与多态的冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-3-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="nav-number">11.4.2.3.</span> <span class="nav-text">9.4.3 泛型与数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">11.5.</span> <span class="nav-text">9.5 参考资料</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E6%B3%A8%E8%A7%A3"><span class="nav-number">12.</span> <span class="nav-text">十、注解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E7%89%B9%E6%80%A7"><span class="nav-number">13.</span> <span class="nav-text">十一、特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">13.1.</span> <span class="nav-text">Java 各版本的新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">13.1.1.</span> <span class="nav-text">1 JDK1.8新特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JDK1-7-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">13.1.2.</span> <span class="nav-text">2 JDK1.7 新特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E4%B8%8E-C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">13.2.</span> <span class="nav-text">Java 与 C++ 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JRE-or-JDK"><span class="nav-number">13.3.</span> <span class="nav-text">JRE or JDK</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81IO"><span class="nav-number">14.</span> <span class="nav-text">十二、IO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%94%E5%A4%A7IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">14.1.</span> <span class="nav-text">1 操作系统的五大IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO"><span class="nav-number">14.1.1.</span> <span class="nav-text">阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">14.1.2.</span> <span class="nav-text">非阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO"><span class="nav-number">14.1.3.</span> <span class="nav-text">多路复用IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="nav-number">14.1.4.</span> <span class="nav-text">信号驱动IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5IO"><span class="nav-number">14.1.5.</span> <span class="nav-text">异步IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E5%A4%A7IO%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="nav-number">14.1.6.</span> <span class="nav-text">五大IO模型对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84select%E3%80%81poll%E3%80%81epoll%E6%9C%BA%E5%88%B6"><span class="nav-number">14.2.</span> <span class="nav-text">2 操作系统的select、poll、epoll机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select"><span class="nav-number">14.2.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll"><span class="nav-number">14.2.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll"><span class="nav-number">14.2.3.</span> <span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94"><span class="nav-number">14.2.4.</span> <span class="nav-text">三者对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83-1"><span class="nav-number">14.2.5.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-JAVA%E6%8F%90%E4%BE%9B%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">14.3.</span> <span class="nav-text">3 JAVA提供的BIO、NIO、AIO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO%EF%BC%88%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO%EF%BC%89"><span class="nav-number">14.3.1.</span> <span class="nav-text">BIO（同步阻塞IO）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO%EF%BC%88%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO%EF%BC%89"><span class="nav-number">14.3.2.</span> <span class="nav-text">NIO（同步非阻塞IO）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AIO%EF%BC%88%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO%EF%BC%89"><span class="nav-number">14.3.3.</span> <span class="nav-text">AIO（异步非阻塞IO）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Reactor%EF%BC%88Netty%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%89IO-%E6%A8%A1%E5%9E%8B"><span class="nav-number">14.4.</span> <span class="nav-text">4 Reactor（Netty使用的）IO 模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Reactor%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">14.4.1.</span> <span class="nav-text">4.1 Reactor基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Reactor%E6%A8%A1%E5%9E%8B%E6%9E%84%E6%88%90"><span class="nav-number">14.4.2.</span> <span class="nav-text">4.2 Reactor模型构成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Reactor%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.4.3.</span> <span class="nav-text">4.3 Reactor模型实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">14.4.3.1.</span> <span class="nav-text">4.3.1 单Reactor单线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">14.4.3.2.</span> <span class="nav-text">4.3.2 单Reactor多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E5%A4%9AReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">14.4.3.3.</span> <span class="nav-text">4.3.3 多Reactor多线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E6%80%BB%E7%BB%93"><span class="nav-number">14.4.4.</span> <span class="nav-text">4.4 总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E9%9B%86%E5%90%88"><span class="nav-number">15.</span> <span class="nav-text">十三、集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">15.0.1.</span> <span class="nav-text">1 HashMap实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">15.0.1.1.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">15.0.1.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PUT-%E6%96%B9%E6%B3%95"><span class="nav-number">15.0.1.3.</span> <span class="nav-text">PUT()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GET-%E6%96%B9%E6%B3%95"><span class="nav-number">15.0.1.4.</span> <span class="nav-text">GET()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">15.0.1.5.</span> <span class="nav-text">扩容机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">15.0.1.6.</span> <span class="nav-text">HashMap线程安全问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">15.0.2.</span> <span class="nav-text">2 ConcurrentHashMap实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-1"><span class="nav-number">15.0.2.1.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="nav-number">15.0.2.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PUT-%E6%96%B9%E6%B3%95-1"><span class="nav-number">15.0.2.3.</span> <span class="nav-text">PUT()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GET-%E6%96%B9%E6%B3%95-1"><span class="nav-number">15.0.2.4.</span> <span class="nav-text">GET()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6-1"><span class="nav-number">15.0.2.5.</span> <span class="nav-text">扩容机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#size-%E6%96%B9%E6%B3%95"><span class="nav-number">15.0.2.6.</span> <span class="nav-text">size()方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-JDK1-8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="nav-number">15.0.3.</span> <span class="nav-text">3 JDK1.8为什么使用红黑树？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">15.0.4.</span> <span class="nav-text">4 HashMap和HashTable的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-ArrayList%E5%92%8CVector%E5%8E%9F%E7%90%86"><span class="nav-number">15.0.5.</span> <span class="nav-text">5 ArrayList和Vector原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="nav-number">15.0.6.</span> <span class="nav-text">6 ArrayList和LinkedList区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">16.</span> <span class="nav-text">其它面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Java%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">16.0.1.</span> <span class="nav-text">1 Java和C++的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ClassNotFoundException%E5%92%8C-NoClassDefFoundError%E5%8C%BA%E5%88%AB"><span class="nav-number">16.0.2.</span> <span class="nav-text">2 ClassNotFoundException和 NoClassDefFoundError区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ClassNotFoundException"><span class="nav-number">16.0.2.1.</span> <span class="nav-text">ClassNotFoundException</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NoClassDefFoundError"><span class="nav-number">16.0.2.2.</span> <span class="nav-text">NoClassDefFoundError</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">17.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WuSanLiu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">39.7k</span>
  
</div>
<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>

-->


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/libchangebyme/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/libchangebyme/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/libchangebyme/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/libchangebyme/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/libchangebyme/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/libchangebyme/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
